{"pages":[{"title":"about","text":"关于我自己首先我是个失败者，创业失败，考研失败。反思失败的过程中，我逐渐认清自己，缺点有懒散，骄傲，充满野心。其次我是个工程师，折腾DIY,刨根问底，善于学习查阅资料，能够解决工程中的难题。最后我是个中国人，位卑未敢忘忧国。 座右铭给时光以生命，而非给生命以时光。给岁月以文明，而非给文明以岁月。 做人十六字 家训 为人处世之道1.要终生学习别放弃一切学习的机会，从生活中学习，从身边的人身上学习,总有自己需要学习的，还要把它变成自己的。 2.要端正态度态度决定一切，付出和收获是成正比的。做任何事情之前，要端正自己的态度，摆正自己的位置。 3.要善于沟通学会与人沟通和交流。沟通要有思想，有逻辑，有解决方案；沟通要一语中的、言简意赅；沟通表达要得体恰当。 4.要热爱生活尽量做自己喜欢的事情，热爱生活才能热爱工作，先做应该做的，再做喜欢做的。 5.要学会做人做人永远比做事更重要。虚虚实实做梦，踏踏实实做事，老老实实做人，忠忠实实作伴，扎扎实实做学问。","link":"/about/index.html"}],"posts":[{"title":"ZBar源码分析——Image_Scanner关键函数","text":"ZBar源码分析——Image Scanner关键函数一、Image ScannerImage Scanner是ZBar实现对读入图像进行扫描的功能模块。Image Scanner的核心主要由img_scanner.c和scanner.c两个文件组成。 其中，img_scanner.c中的核心函数是zbar_scan_image()，而scanner.c中的核心函数是zbar_scan_y()。经过简单分析得到，zbar_scan_image主要负责ZBar对读入图像的扫描工作，函数主要根据设定的扫描密度(density)控制像素点读取(按Z字形读取，这也是ZBar名称的由来)，scanner.c文件内的zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 二、关键函数（补充说明）12345static inline unsigned calc_thresh (zbar_scanner_t *scn)dx = x - lastedge；t = thresh*dx;t /= scn-&gt;width;t /=8; 这一段程序主要是为了使thresh逐渐回归到thresh_min。 如果dx在8width范围内，则thresh=thresh（1-dx/8w） 即如果dx=width，则thresh=7/8thresh。如果dx超出8w范围，则直接置为thresh_min。 thresh在每次确定新的边界时更新为此处的y11的0.44倍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273zbar_symbol_type_t zbar_scan_y (zbar_scanner_t *scn, int y){ /* FIXME calc and clip to max y range... */ /* retrieve short value history */ register int x = scn-&gt;x; register int y0_1 = scn-&gt;y0[(x - 1) &amp; 3]; register int y0_0 = y0_1; register int y0_2, y0_3, y1_1, y2_1, y2_2; zbar_symbol_type_t edge; if(x) { /* update weighted moving average */ y0_0 += ((int)((y - y0_1) * EWMA_WEIGHT)) &gt;&gt; ZBAR_FIXED; scn-&gt;y0[x &amp; 3] = y0_0; } else y0_0 = y0_1 = scn-&gt;y0[0] = scn-&gt;y0[1] = scn-&gt;y0[2] = scn-&gt;y0[3] = y; y0_2 = scn-&gt;y0[(x - 2) &amp; 3]; y0_3 = scn-&gt;y0[(x - 3) &amp; 3]; /* 1st differential @ x-1 */ y1_1 = y0_1 - y0_2; { register int y1_2 = y0_2 - y0_3; if((abs(y1_1) &lt; abs(y1_2)) &amp;&amp; ((y1_1 &gt;= 0) == (y1_2 &gt;= 0))) y1_1 = y1_2; } /* 2nd differentials @ x-1 &amp; x-2 */ y2_1 = y0_0 - (y0_1 * 2) + y0_2; y2_2 = y0_1 - (y0_2 * 2) + y0_3; dbprintf(1, &quot;scan: x=%d y=%d y0=%d y1=%d y2=%d&quot;, x, y, y0_1, y1_1, y2_1); edge = ZBAR_NONE; /* 2nd zero-crossing is 1st local min/max - could be edge */ if((!y2_1 || ((y2_1 &gt; 0) ? y2_2 &lt; 0 : y2_2 &gt; 0)) &amp;&amp; (calc_thresh(scn) &lt;= abs(y1_1))) { /* check for 1st sign change */ char y1_rev = (scn-&gt;y1_sign &gt; 0) ? y1_1 &lt; 0 : y1_1 &gt; 0; if(y1_rev) /* intensity change reversal - finalize previous edge */ edge = process_edge(scn, y1_1); if(y1_rev || (abs(scn-&gt;y1_sign) &lt; abs(y1_1))) { int d; scn-&gt;y1_sign = y1_1; /* adaptive thresholding */ /* start at multiple of new min/max */ scn-&gt;y1_thresh = (abs(y1_1) * THRESH_INIT + ROUND) &gt;&gt; ZBAR_FIXED; dbprintf(1, &quot;\\tthr=%d&quot;, scn-&gt;y1_thresh); if(scn-&gt;y1_thresh &lt; scn-&gt;y1_min_thresh) scn-&gt;y1_thresh = scn-&gt;y1_min_thresh; /* update current edge */ d = y2_1 - y2_2; scn-&gt;cur_edge = 1 &lt;&lt; ZBAR_FIXED; if(!d) scn-&gt;cur_edge &gt;&gt;= 1; else if(y2_1) /* interpolate zero crossing */ scn-&gt;cur_edge -= ((y2_1 &lt;&lt; ZBAR_FIXED) + 1) / d; scn-&gt;cur_edge += x &lt;&lt; ZBAR_FIXED; dbprintf(1, &quot;\\n&quot;); } } else dbprintf(1, &quot;\\n&quot;); /* FIXME add fall-thru pass to decoder after heuristic &quot;idle&quot; period(eg, 6-8 * last width) */ scn-&gt;x = x + 1; return(edge);} 寄存器变量1234register int x = scn-&gt;x;register int y0_1 = scn-&gt;y0[(x - 1) &amp; 3];register int y0_0 = y0_1;register int y0_2, y0_3, y1_1, y2_1, y2_2; Tips： 1.寄存器变量可以用来优化加速c语言程序 2.声名只需在类型前多加register 即可，eg register int quick; （quick 就是一个整形的寄存器变量） 3.register只是一个建议型关键字，能不能声名成功还取决于编译器（建议型的关键字还有c++中的 inline），若不幸没有请求成功，则变量变成一个普通的自动变量。 4.是无法对一个register变量取地址的（因为寄存器变量多放在寄存器而非内存中，内存有地址，而寄存器是无地址的） 5.即便没有请求成寄存器变量，没有如愿的放入寄存器中，但是，依然不能对他取地址，因为他已经被声明为register了 什么情况用寄存器变量： 当对一个变量频繁被读写时，需要反复访问内存，从而花费大量的存取时间。为此，C语言提供了一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量，而循环计数是应用寄存器变量的最好候选者。 什么变量可以声明为寄存器变量： 只有局部自动变量和形参才可以定义为寄存器变量。因为寄存器变量属于动态存储方式，凡需要采用静态存储方式的量都不能定义为寄存器变量,因为静态变量储存在静态区，包括：模块间全局变量、模块内全局变量、局部static变量。 1234567891011121314151617if(x) { /* update weighted moving average */ y0_0 += ((int)((y - y0_1) * EWMA_WEIGHT)) &gt;&gt; ZBAR_FIXED; scn-&gt;y0[x &amp; 3] = y0_0; } else y0_0 = y0_1 = scn-&gt;y0[0] = scn-&gt;y0[1] = scn-&gt;y0[2] = scn-&gt;y0[3] = y; y0_2 = scn-&gt;y0[(x - 2) &amp; 3]; y0_3 = scn-&gt;y0[(x - 3) &amp; 3]; /* 1st differential @ x-1 */ y1_1 = y0_1 - y0_2; { register int y1_2 = y0_2 - y0_3; if((abs(y1_1) &lt; abs(y1_2)) &amp;&amp; ((y1_1 &gt;= 0) == (y1_2 &gt;= 0))) y1_1 = y1_2; } 函数一开头使用EWMA对原始数据滤波，抑制突变。 再用y0数组存储邻近点的数据，用来求一阶导数和二阶导数， scn-&gt;y0[(x - 1) &amp; 3]很巧妙的限制住了数组索引不越界，循环使用。 紧接着开始求一阶导，二阶导。 12345678/* 1st differential @ x-1 */ y1_1 = y0_1 - y0_2; { register int y1_2 = y0_2 - y0_3; if((abs(y1_1) &lt; abs(y1_2)) &amp;&amp; ((y1_1 &gt;= 0) == (y1_2 &gt;= 0))) y1_1 = y1_2; } 一阶求导数，如果同向且变化率减小，那么认为变化率为常数，此针对屋顶变化边界类型。 三、总结本次博客对ZBar扫描器的几个重要函数的代码进行了补充说明。如有不足，敬请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Image-Scanner%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/"},{"title":"ZBar源码分析——Image-Scanner模块_4","text":"ZBar源码分析——Image Scanner模块（四）[TOC] 一、Image ScannerImage Scanner，顾名思义是实现对读入图像进行扫描的功能模块。 ZBar实现Image Scanner的核心主要由img_scanner.c和scanner.c两个文件组成。 其中，img_scanner.c中的核心函数是zbar_scan_image()，而scanner.c中的核心函数是zbar_scan_y()。经过简单分析得到，zbar_scan_image主要负责ZBar对读入图像的扫描工作，函数主要根据设定的扫描密度(density)控制像素点读取(按Z字形读取，这也是ZBar名称的由来)，scanner.c文件内的zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 前面的代码分析对img_scanner.c的核心函数zbar_scan_image()函数以及几个函数进行过分析，本次代码分析则继续对该模块对于特征的分配和处理方式进行补充，并展开其关于缓存和配置的代码分析。 二、代码分析扫描器特征分配123456_zbar_image_scanner_alloc_sym (zbar_image_scanner_t *iscn, zbar_symbol_type_t type, int datalen){...} 扫描器特征分配的功能主要由_zbar_image_scanner_alloc_sym函数实现，这一函数的工作主要有两个方面： （1）回收旧的特征 （2）为扫描器分配新的特征 123456789101112131415161718192021zbar_symbol_t *sym = NULL; int i; for(i = 0; i &lt; RECYCLE_BUCKETS - 1; i++) if(datalen &lt;= 1 &lt;&lt; (i * 2)) break; for(; i &gt; 0; i--) if((sym = iscn-&gt;recycle[i].head)) { STAT(sym_recycle[i]); break; } if(sym) { iscn-&gt;recycle[i].head = sym-&gt;next; sym-&gt;next = NULL; assert(iscn-&gt;recycle[i].nsyms); iscn-&gt;recycle[i].nsyms--; } else { sym = calloc(1, sizeof(zbar_symbol_t)); STAT(sym_new); } 扫描器首先对其之前分配过的特征进行回收。 这一步分为两种情况： 若该扫描器中之前被分配过特征，则对其进行直接回收； 若该扫描器为刚初始化过的扫描器，则不能像上面那样操作，否则会出现空指针异常，这时则需要为扫描器初始化一个新的特征向量。 在回收开始之前，首先需要进行一系列判断： 首先要对在上篇博客中提到的扫描器回收站以及扫描器循环体进行检查，若其中还有未处理的数据，则终止函数执行。 若通过了上一步的代码检查，则遍历指针，对其进行逐一回收。 12345678910111213141516if(datalen &gt; 0) { sym-&gt;datalen = datalen - 1; if(sym-&gt;data_alloc &lt; datalen) { if(sym-&gt;data) free(sym-&gt;data); sym-&gt;data_alloc = datalen; sym-&gt;data = malloc(datalen); } } else { if(sym-&gt;data) free(sym-&gt;data); sym-&gt;data = NULL; sym-&gt;datalen = sym-&gt;data_alloc = 0; } return(sym); 另一方面，在进行特征初始化及分配时，需要对特征向量的长度与扫描器预留空间进行判断，若当前特征向量无法分配到该扫描器中，则释放刚初始化的特征，将该空间留给合适的特征向量。 特征处理这一功能的实现需要借助解码器。 特征处理器数据初始化：对特征类型、特征尺寸以及解码得到的数据内容进行初始化。 123456zbar_image_scanner_t *iscn = zbar_decoder_get_userdata(dcode); zbar_symbol_type_t type = zbar_decoder_get_type(dcode); int x = 0, y = 0, dir; const char *data; unsigned datalen;c zbar_symbol_t *sym; 为扫描位置选择一个临时位置并固定，并获取边界。 123456789101112if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) { int w = zbar_scanner_get_width(iscn-&gt;scn); int u = iscn-&gt;umin + iscn-&gt;du * zbar_scanner_get_edge(iscn-&gt;scn, w, 0); if(iscn-&gt;dx) { x = u; y = iscn-&gt;v; } else { x = iscn-&gt;v; y = u; } } 保存/显示所有解码部分的数据标识 1234567if(type &lt;= ZBAR_PARTIAL) { zprintf(256, &quot;partial symbol @(%d,%d)\\n&quot;, x, y); return; } data = zbar_decoder_get_data(dcode); datalen = zbar_decoder_get_data_length(dcode); 为扫描器匹配更加合适的特征，并将新的特征点添加到现有集合 1234567891011121314151617for(sym = iscn-&gt;syms-&gt;head; sym; sym = sym-&gt;next) if(sym-&gt;type == type &amp;&amp; sym-&gt;datalen == datalen &amp;&amp; !memcmp(sym-&gt;data, data, datalen)) { sym-&gt;quality++; zprintf(224, &quot;dup symbol @(%d,%d): dup %s: %.20s\\n&quot;, x, y, zbar_get_symbol_name(type), data); if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) /* add new point to existing set *//* FIXME should be polygon */sym_add_point(sym, x, y);return;} sym = _zbar_image_scanner_alloc_sym(iscn, type, datalen + 1); sym-&gt;configs = zbar_decoder_get_configs(dcode, type); sym-&gt;modifiers = zbar_decoder_get_modifiers(dcode); 初始化第一个特征向量 123456789 if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) { zprintf(192, &quot;new symbol @(%d,%d): %s: %.20s\\n&quot;, x, y, zbar_get_symbol_name(type), data); sym_add_point(sym, x, y); } dir = zbar_decoder_get_direction(dcode); if(dir) sym-&gt;orient = (iscn-&gt;dy != 0) + ((iscn-&gt;du ^ dir) &amp; 2);_zbar_image_scanner_add_sym(iscn, sym); 以上就是关于扫描器特征部分要补充的代码说明。 下面对扫描器cache部分的代码展开解析。 缓存过滤器ZBar扫描器中的缓存过滤器有以下功能： *主要用于扫描视频帧 *从连续图像中复制扫描结果 *一致性检查和结果滞后 *清除缓存 启动/禁用缓存过滤器12345678910void zbar_image_scanner_enable_cache (zbar_image_scanner_t *iscn, int enable){ if(iscn-&gt;cache) { /* recycle all cached syms */ _zbar_image_scanner_recycle_syms(iscn, iscn-&gt;cache); iscn-&gt;cache = NULL; } iscn-&gt;enable_cache = (enable) ? 1 : 0;} 扫描器接口默认禁用缓存过滤器（通过enable参数控制）。 当要启用缓存过滤器时，设定enable为1，这时扫描器会将缓存中的特征向量全部回收，并准备启动缓存。 访问Cache访问扫描器的缓存内容时，要进行以下工作： （1）寻找访存入口 （2）回收过时缓存项：在访存时，若发现缓存区中有特征的形成时间与进入缓存区的时间的时间差过长，则判定为超时特征，并对其进行回收。 123456789101112131415while(*entry) { if((*entry)-&gt;type == sym-&gt;type &amp;&amp; (*entry)-&gt;datalen == sym-&gt;datalen &amp;&amp; !memcmp((*entry)-&gt;data, sym-&gt;data, sym-&gt;datalen)) break; if((sym-&gt;time - (*entry)-&gt;time) &gt; CACHE_TIMEOUT) { /* recycle stale cache entry */ zbar_symbol_t *next = (*entry)-&gt;next; (*entry)-&gt;next = NULL; _zbar_image_scanner_recycle_syms(iscn, *entry); *entry = next; } else entry = &amp;(*entry)-&gt;next; } 在Cache中缓存特征当启用缓存过滤器，则允许扫描器在缓存区中存放特征，这相当于在内存中开辟一块空间，用于临时存放特征向量，实现高速存取。 启用缓存过滤器后，要访问Cache时，首先寻找缓存入口，若没有找到，则声明一个新的扫描器，将其初始化后，得到缓存空间和缓存入口。 12345678910111213141516if(iscn-&gt;enable_cache) { uint32_t age, near_thresh, far_thresh, dup; zbar_symbol_t *entry = cache_lookup(iscn, sym); if(!entry) { /* FIXME reuse sym */ entry = _zbar_image_scanner_alloc_sym(iscn, sym-&gt;type, sym-&gt;datalen + 1); entry-&gt;configs = sym-&gt;configs; entry-&gt;modifiers = sym-&gt;modifiers; memcpy(entry-&gt;data, sym-&gt;data, sym-&gt;datalen); entry-&gt;time = sym-&gt;time - CACHE_HYSTERESIS; entry-&gt;cache_count = 0; /* add to cache */ entry-&gt;next = iscn-&gt;cache; iscn-&gt;cache = entry; }s 接下来进行一致性检查 1234567891011121314age = sym-&gt;time - entry-&gt;time; entry-&gt;time = sym-&gt;time; near_thresh = (age &lt; CACHE_PROXIMITY); far_thresh = (age &gt;= CACHE_HYSTERESIS); dup = (entry-&gt;cache_count &gt;= 0); if((!dup &amp;&amp; !near_thresh) || far_thresh) { int type = sym-&gt;type; int h = _zbar_get_symbol_hash(type); entry-&gt;cache_count = -iscn-&gt;sym_configs[0][h]; } else if(dup || near_thresh) entry-&gt;cache_count++; sym-&gt;cache_count = entry-&gt;cache_count; 通过一致性检查后，则允许使用缓存实现高速存取。 三、总结本次代码分析对扫描器模块对于特征的分配和处理方式进行了补充，并对其关于缓存过滤器的代码进行了分析。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Image-Scanner%E6%A8%A1%E5%9D%97-4/"},{"title":"ZBar源码分析——Image-Scanner模块_3","text":"ZBar源码分析——Image Scanner模块（三）[TOC] 一、Image ScannerImage Scanner，顾名思义是实现对读入图像进行扫描的功能模块。 ZBar实现Image Scanner的核心主要由img_scanner.c和scanner.c两个文件组成。 其中，img_scanner.c中的核心函数是zbar_scan_image()，而scanner.c中的核心函数是zbar_scan_y()。经过简单分析得到，zbar_scan_image主要负责ZBar对读入图像的扫描工作，函数主要根据设定的扫描密度(density)控制像素点读取(按Z字形读取，这也是ZBar名称的由来)，scanner.c文件内的zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 前面的代码分析对img_scanner.c的核心函数zbar_scan_image()函数以及几个函数进行过分析，本次代码分析则继续对该函数对于特征的使用和处理进行分析。 二、代码分析数据结构解析1234567891011121314151617181920212223242526272829303132333435typedef struct recycle_bucket_s { int nsyms; zbar_symbol_t *head;} recycle_bucket_t;/* image scanner state */struct zbar_image_scanner_s { zbar_scanner_t *scn; /* associated linear intensity scanner */ zbar_decoder_t *dcode; /* associated symbol decoder */#ifdef ENABLE_QRCODE qr_reader *qr; /* QR Code 2D reader */#endif const void *userdata; /* application data */ /* user result callback */ zbar_image_data_handler_t *handler; unsigned long time; /* scan start time */ zbar_image_t *img; /* currently scanning image *root* */ int dx, dy, du, umin, v; /* current scan direction */ zbar_symbol_set_t *syms; /* previous decode results */ /* recycled symbols in 4^n size buckets */ recycle_bucket_t recycle[RECYCLE_BUCKETS]; int enable_cache; /* current result cache state */ zbar_symbol_t *cache; /* inter-image result cache entries */ /* configuration settings */ unsigned config; /* config flags */ unsigned ean_config; int configs[NUM_SCN_CFGS]; /* int valued configurations */ int sym_configs[1][NUM_SYMS]; /* per-symbology configurations */#ifndef NO_STATS int stat_syms_new; int stat_iscn_syms_inuse, stat_iscn_syms_recycle; int stat_img_syms_inuse, stat_img_syms_recycle; int stat_sym_new; int stat_sym_recycle[RECYCLE_BUCKETS];#endif}; 这里定义了两个数据结构用于代码调用。 recycle_bucket_s为特征回收数据结构，在结构体中定义了特征指针和索引数据。 zbar_image_scanner_s为ZBar扫描器数据结构，存放当前扫描器的状态、用户反馈数据、被回收的特征数据以及扫描器配置数据。 zbar_scanner_t *scn 与扫描器关联的线性强度扫描仪 zbar_decoder_t *dcode 与扫描器关联的关联符号解码器 qr_reader *qr 二维码阅读器 const void *userdata 应用数据 unsigned long time 扫描开始时间 zbar_image_t *img 当前扫描图像 int dx, dy, du, umin, v 当前扫描位置 zbar_symbol_set_t *syms 曾经被解码得到的结果 int enable_cache 当前结果缓存状态 unsigned config 配置标志 int configs[NUM_SCN_CFGS] 有值配置 int sym_configs[1][NUM_SYMS] 符号配置 扫描器特征回收扫描器在对二维图像进行扫描时，将识别到的特征进行记录和保存，当当前扫描部分结束时，需要对特征进行回收。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void _zbar_image_scanner_recycle_syms (zbar_image_scanner_t *iscn, zbar_symbol_t *sym){ zbar_symbol_t *next = NULL; for(; sym; sym = next) { next = sym-&gt;next; if(sym-&gt;refcnt &amp;&amp; _zbar_refcnt(&amp;sym-&gt;refcnt, -1)) { /* unlink referenced symbol */ /* FIXME handle outstanding component refs (currently unsupported)*/ assert(sym-&gt;data_alloc); sym-&gt;next = NULL; } else { int i; recycle_bucket_t *bucket; /* recycle unreferenced symbol */ if(!sym-&gt;data_alloc) { sym-&gt;data = NULL; sym-&gt;datalen = 0; } if(sym-&gt;syms) { if(_zbar_refcnt(&amp;sym-&gt;syms-&gt;refcnt, -1)) assert(0); _zbar_image_scanner_recycle_syms(iscn, sym-&gt;syms-&gt;head); sym-&gt;syms-&gt;head = NULL; _zbar_symbol_set_free(sym-&gt;syms); sym-&gt;syms = NULL; } for(i = 0; i &lt; RECYCLE_BUCKETS; i++) if(sym-&gt;data_alloc &lt; 1 &lt;&lt; (i * 2)) break; if(i == RECYCLE_BUCKETS) { assert(sym-&gt;data); free(sym-&gt;data); sym-&gt;data = NULL; sym-&gt;data_alloc = 0; i = 0; } bucket = &amp;iscn-&gt;recycle[i]; /* FIXME cap bucket fill */ bucket-&gt;nsyms++; sym-&gt;next = bucket-&gt;head; bucket-&gt;head = sym; } }} 回收步骤： 遍历扫描器存放的特征数据结构，若当前特征与当前扫描器链接且被引用，则直接在特征列表中截断，不允许在链表中继续链接，然后断开链接。 1234567if(sym-&gt;refcnt &amp;&amp; _zbar_refcnt(&amp;sym-&gt;refcnt, -1)) { /* unlink referenced symbol */ /* FIXME handle outstanding component refs (currently unsupported) */ assert(sym-&gt;data_alloc); sym-&gt;next = NULL; } 若未被引用，则不能在链表中进行操作，这部分数据在扫描器中的存储结构比较尴尬：可能在后续扫描过程中被引用，即被其他扫描器结构引用。 在回收时，需要调用回收桶数据结构，将这部分数据存放到回收桶中，这与Windows系统中的回收站功能类似，只是将这部分数据结构从扫描器中移除，在某个地方存放起来，需要时仍可以调用。 该函数也提供了将回收桶中的数据彻底移除的方式。 12345678910for(i = 0; i &lt; RECYCLE_BUCKETS; i++) if(sym-&gt;data_alloc &lt; 1 &lt;&lt; (i * 2)) break; if(i == RECYCLE_BUCKETS) { assert(sym-&gt;data); free(sym-&gt;data); sym-&gt;data = NULL; sym-&gt;data_alloc = 0; i = 0; } 扫描器图像回收当扫描器要对链接的图像进行回收时，就需要借助特征回收函数。另一方面，该函数被设定为内联函数，说明这个函数在ZBar执行过程中频繁被调用。 12345678910111213141516171819202122232425inline void zbar_image_scanner_recycle_image (zbar_image_scanner_t *iscn, zbar_image_t *img){ zbar_symbol_set_t *syms = iscn-&gt;syms; if(syms &amp;&amp; syms-&gt;refcnt) { if(recycle_syms(iscn, syms)) { STAT(iscn_syms_inuse); iscn-&gt;syms = NULL; } else STAT(iscn_syms_recycle); } syms = img-&gt;syms; img-&gt;syms = NULL; if(syms &amp;&amp; recycle_syms(iscn, syms)) STAT(img_syms_inuse); else if(syms) { STAT(img_syms_recycle); /* select one set to resurrect, destroy the other */ if(iscn-&gt;syms) _zbar_symbol_set_free(syms); else iscn-&gt;syms = syms; }} ZBar在回收（循环）图像时采用的方式是：遍历所有图像特征，根据特征标识符选择复活一组图像特征，然后销毁一组图像特征，实现内存空间有效利用，不占用过多内存空间。 扫描器新增特征前面分析了扫描器对特征的回收和断开链接的过程，与之相对的，扫描器同样也需要加入新的特征的功能。 1234567891011121314151617181920void _zbar_image_scanner_add_sym(zbar_image_scanner_t *iscn, zbar_symbol_t *sym){ zbar_symbol_set_t *syms; cache_sym(iscn, sym); syms = iscn-&gt;syms; if(sym-&gt;cache_count || !syms-&gt;tail) { sym-&gt;next = syms-&gt;head; syms-&gt;head = sym; } else { sym-&gt;next = syms-&gt;tail-&gt;next; syms-&gt;tail-&gt;next = sym; } if(!sym-&gt;cache_count) syms-&gt;nsyms++; else if(!syms-&gt;tail) syms-&gt;tail = sym; _zbar_symbol_refcnt(sym, 1);} 这里对特征的数据结构zbar_symbol_s进行补充分析： zbar_symbol_type_t type 符号类型 unsigned int configs 符号布尔配置位掩码 unsigned int modifiers 符号修饰符位掩码 unsigned int data_alloc 数据的分配大小 unsigned int datalen 二进制符号数据的长度 char *data 符号数据 unsigned pts_alloc pts的分配大小 unsigned npts 位置多边形中的点数 point_t *pts 位置多边形中的点列表 zbar_orientation_t orient 粗方向 refcnt_t refcnt 引用计数 zbar_symbol_t *next 结果（或同级）链接列表 zbar_symbol_set_t *syms 分量 unsigned long time 相对符号捕获时间 int cache_count 缓存状态 int quality 相对符号可靠性度量 以及特征集zbar_symbol_set_s的数据结构： refcnt_t refcnt 索引标识 int nsyms 已过滤特征的数量 zbar_symbol_t *head 第一个解码特征结果 zbar_symbol_t *tail 最后一个未过滤的特征结果 在扫描器中添加新特征时，需要对特征的缓存状态和在特征集合中的位置进行判断，有以下几种情况： （1）特征已被缓存或者当前特征不在集合的尾部，则直接在特征集合中插入新特征。 （2）特征未被缓存且者当前特征在集合的尾部，则改变集合尾部指针指向，在尾部添加新特征。 （3）对于未缓存的特征，加入集合中还需要对索引和对已过滤特征进行变更。 三、总结本次代码分析对扫描器关于特征的回收和新增，以及特征和图像间的处理方式进行分析，下次将对扫描器配置和缓存部分展开分析。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Image-Scanner%E6%A8%A1%E5%9D%97-3/"},{"title":"ZBar源码分析——Window模块解析_1","text":"[TOC] 一、Window模块 要使用ZBar进行条码识别的时候，输入的可以是视频流也可以是图像流。 在采用视频流进行输入的情况下，我们往往采取的方式是打开摄像头窗口进行扫码识别。在摄像头捕获到的视频信息中，ZBar需要对视频信息进行一系列的采集和处理，如逐帧捕获等等。Window模块会将处理后的信息交给其他模块进行解码等处理。 采用图像输入时，也需要Window模块的参与，这会在后续代码分析中提到。 这部分功能的实现并不是由Video模块实现，而是在ZBar打开窗口时，由Window模块进行实现的。这样的模块分离，使得整个项目的结构更加清晰，各模块之间的分工更加明确。 除此之外，根据ZBar的项目流程，可以看到，Window模块还有一个核心功能为将图像显示到用户指定的特定于平台的输出窗口。 ZBar项目的核心代码大部分都在zbar文件夹下，而zbar文件夹下的window.h和window.c则负责了这一模块的核心功能实现，而具体的调用实现则是在Processor处理模块以及其他api中完成。 本次代码分析将从window.h和window.c中展开。 二、代码分析window数据结构解析根据代码中的注释，给出数据结构中每个属性的补充说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071`1. struct zbar_window_s { 2. errinfo_t err; /* 报错信息 */ 3. zbar_image_t *image; /* 上一张显示的图像 */ 4. /* 该图像信息的访问权限必须上锁 */ 6. unsigned overlay; /* 用户设定的覆盖等级 */ 8. uint32_t format; /* 输出格式 */ 9. unsigned width, height; /* 当前输出尺寸 */ 10. unsigned max_width, max_height; 12. uint32_t src_format; /* 当前输入格式 */ 13. unsigned src_width; /* 上一张显示图像的尺寸 */ 14. unsigned src_height; 16. unsigned dst_width; /* 转换目标的图像尺寸 */ 17. unsigned dst_height; 19. unsigned scale_num; /* 输出缩放尺度 */ 20. unsigned scale_den; 22. point_t scaled_offset; /* 输出位置和大小 */ 23. point_t scaled_size; 25. uint32_t *formats; /* 支持的格式（必须以0结尾） */ 27. zbar_mutex_t imglock; /* 锁定当前显示的图像 */ 29. void *display; 30. unsigned long xwin; 31. unsigned long time; /* 以毫秒为单位显示图像 */ 32. unsigned long time_avg; /* 帧间时间的平均值 */ 34. window_state_t *state; /* 接口特定状态 */ 36. /* 依赖接口的方法 */ 37. int (*init)(zbar_window_t*, zbar_image_t*, int); 38. int (*draw_image)(zbar_window_t*, zbar_image_t*); 39. int (*cleanup)(zbar_window_t*); 40. }; Window线程的上锁与解锁在代码注释中提到，在渲染窗口时，必须保证渲染函数window.draw是线程安全的。ZBar对于线程安全方面的处理都是采用互斥锁和信号量实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253`1. static inline int window_lock (zbar_window_t *w) 2. { 3. int rc = 0; 4. if((rc = _zbar_mutex_lock(&amp;w-&gt;imglock))) { 5. err_capture(w, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 6. &quot;unable to acquire lock&quot;); 7. w-&gt;err.errnum = rc; 8. return(-1); 9. } 10. return(0); 11. } 13. static inline int window_unlock (zbar_window_t *w) 14. { 15. int rc = 0; 16. if((rc = _zbar_mutex_unlock(&amp;w-&gt;imglock))) { 17. err_capture(w, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 18. &quot;unable to release lock&quot;); 19. w-&gt;err.errnum = rc; 20. return(-1); 21. } 22. return(0); 23. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 当有渲染窗口的线程获得了互斥锁，其他线程则必须等待，直到其释放锁。 而关于互斥锁的具体实现，则在mutex.c中体现，后续有机会再进行解析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445`1. zbar_window_t *zbar_window_create () 2. { 3. zbar_window_t *w = calloc(1, sizeof(zbar_window_t)); 4. if(!w) 5. return(NULL); 6. err_init(&amp;w-&gt;err, ZBAR_MOD_WINDOW); 7. w-&gt;overlay = 1; 8. (void)_zbar_mutex_init(&amp;w-&gt;imglock); 9. return(w); 10. } 12. void zbar_window_destroy (zbar_window_t *w) 13. { 14. /* detach */ 15. zbar_window_attach(w, NULL, 0); 16. err_cleanup(&amp;w-&gt;err); 17. _zbar_mutex_destroy(&amp;w-&gt;imglock); 18. free(w); 19. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) ZBar在创建一个窗口和销毁一个窗口时，同时新建和释放互斥锁。 在创建窗口时，首先为窗口申请内存，并为当前窗口新建互斥锁，当要渲染形成窗口界面时，则通过互斥锁实现线程互斥。 窗口固定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354`1. int zbar_window_attach (zbar_window_t *w, 2. void *display, 3. unsigned long drawable) 4. { 5. /* release image */ 6. zbar_window_draw(w, NULL); 7. if(w-&gt;cleanup) { 8. w-&gt;cleanup(w); 9. w-&gt;cleanup = NULL; 10. w-&gt;draw_image = NULL; 11. } 12. if(w-&gt;formats) { 13. free(w-&gt;formats); 14. w-&gt;formats = NULL; 15. } 16. w-&gt;src_format = 0; 17. w-&gt;src_width = w-&gt;src_height = 0; 18. w-&gt;scaled_size.x = w-&gt;scaled_size.y = 0; 19. w-&gt;dst_width = w-&gt;dst_height = 0; 20. w-&gt;max_width = w-&gt;max_height = 1 &lt;&lt; 15; 21. w-&gt;scale_num = w-&gt;scale_den = 1; 22. return(_zbar_window_attach(w, display, drawable)); 23. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 该函数实现了窗口在平台上的关联和固定。 **这里对外界平台做一下说明：平台可以是 *X Windows *的任何“可绘制”窗口 或 Windows 的“HWND”。 在形式参数中传递 NULL 空值 指定从资源中分离，将显示进一步的输入。 ZBar对窗口销毁时，除了释放了互斥锁，同时还需要对窗口中的当前图像进行释放，并对属性进行重置，并设定为不可渲染。 窗口渲染123456789101112131415161718192021222324252627282930313233343536`1. int zbar_window_draw (zbar_window_t *w, 2. zbar_image_t *img) 3. { 4. if(window_lock(w)) 5. return(-1); 6. if(!w-&gt;draw_image) 7. img = NULL; 8. if(img) { 9. _zbar_image_refcnt(img, 1); 10. if(img-&gt;width != w-&gt;src_width || 11. img-&gt;height != w-&gt;src_height) 12. w-&gt;dst_width = 0; 13. } 14. if(w-&gt;image) 15. _zbar_image_refcnt(w-&gt;image, -1); 16. w-&gt;image = img; 17. return(window_unlock(w)); 18. } 该函数实现了将图像输出到特定窗口。 可以看到，如果执行该函数时，互斥锁已被占用，则不允许执行后续程序。 在将图像输出时，如果出现图像尺寸与窗口尺寸不一致的情况，ZBar会将输出的目标图像的宽置为0，从而实现强制适应。 三、总结本次代码分析对Window模块的几个函数进行了简单说明，关于窗口重渲染以及图层的覆盖处理将在下次分析中给出。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Window%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90-1/"},{"title":"ZBar源码分析——Window模块解析_2","text":"一、Window模块 要使用ZBar进行条码识别的时候，输入的可以是视频流也可以是图像流。 在采用视频流进行输入的情况下，我们往往采取的方式是打开摄像头窗口进行扫码识别。在摄像头捕获到的视频信息中，ZBar需要对视频信息进行一系列的采集和处理，如逐帧捕获等等。Window模块会将处理后的信息交给其他模块进行解码等处理。 采用图像输入时，也需要Window模块的参与，这会在后续代码分析中提到。 这部分功能的实现并不是由Video模块实现，而是在ZBar打开窗口时，由Window模块进行实现的。这样的模块分离，使得整个项目的结构更加清晰，各模块之间的分工更加明确。 除此之外，根据ZBar的项目流程，可以看到，Window模块还有一个核心功能为将图像显示到用户指定的特定于平台的输出窗口。 ZBar项目的核心代码大部分都在zbar文件夹下，而zbar文件夹下的window.h和window.c则负责了这一模块的核心功能实现，而具体的调用实现则是在Processor处理模块以及其他api中完成。 本次代码分析将继上次代码分析展开window.c的解析。 二、代码分析zbar_window_redraw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249`1. inline int zbar_window_redraw (zbar_window_t *w) 2. { 3. int rc = 0; 4. zbar_image_t *img; 5. if(window_lock(w)) 6. return(-1); 7. if(!w-&gt;display || _zbar_window_begin(w)) { 8. (void)window_unlock(w); 9. return(-1); 10. } 12. img = w-&gt;image; 13. if(w-&gt;init &amp;&amp; w-&gt;draw_image &amp;&amp; img) { 14. int format_change = (w-&gt;src_format != img-&gt;format &amp;&amp; 15. w-&gt;format != img-&gt;format); 16. if(format_change) { 17. _zbar_best_format(img-&gt;format, &amp;w-&gt;format, w-&gt;formats); 18. if(!w-&gt;format) 19. rc = err_capture_int(w, SEV_ERROR, ZBAR_ERR_UNSUPPORTED, __func__, 20. &quot;no conversion from %x to supported formats&quot;, 21. img-&gt;format); 22. w-&gt;src_format = img-&gt;format; 23. } 25. if(!rc &amp;&amp; (format_change || !w-&gt;scaled_size.x || !w-&gt;dst_width)) { 26. point_t size = { w-&gt;width, w-&gt;height }; 27. zprintf(24, &quot;init: src=%.4s(%08x) %dx%d dst=%.4s(%08x) %dx%d\\n&quot;, 28. (char*)&amp;w-&gt;src_format, w-&gt;src_format, 29. w-&gt;src_width, w-&gt;src_height, 30. (char*)&amp;w-&gt;format, w-&gt;format, 31. w-&gt;dst_width, w-&gt;dst_height); 32. if(!w-&gt;dst_width) { 33. w-&gt;src_width = img-&gt;width; 34. w-&gt;src_height = img-&gt;height; 35. } 37. if(size.x &gt; w-&gt;max_width) 38. size.x = w-&gt;max_width; 39. if(size.y &gt; w-&gt;max_height) 40. size.y = w-&gt;max_height; 42. if(size.x * w-&gt;src_height &lt; size.y * w-&gt;src_width) { 43. w-&gt;scale_num = size.x; 44. w-&gt;scale_den = w-&gt;src_width; 45. } 46. else { 47. w-&gt;scale_num = size.y; 48. w-&gt;scale_den = w-&gt;src_height; 49. } 51. rc = w-&gt;init(w, img, format_change); 53. if(!rc) { 54. size.x = w-&gt;src_width; 55. size.y = w-&gt;src_height; 56. w-&gt;scaled_size = size = window_scale_pt(w, size); 57. w-&gt;scaled_offset.x = ((int)w-&gt;width - size.x) / 2; 58. w-&gt;scaled_offset.y = ((int)w-&gt;height - size.y) / 2; 59. zprintf(24, &quot;scale: src=%dx%d win=%dx%d by %d/%d =&gt; %dx%d @%d,%d\\n&quot;, 60. w-&gt;src_width, w-&gt;src_height, w-&gt;width, w-&gt;height, 61. w-&gt;scale_num, w-&gt;scale_den, 62. size.x, size.y, w-&gt;scaled_offset.x, w-&gt;scaled_offset.y); 63. } 64. else { 65. /* unable to display this image */ 66. _zbar_image_refcnt(img, -1); 67. w-&gt;image = img = NULL; 68. } 69. } 71. if(!rc &amp;&amp; 72. (img-&gt;format != w-&gt;format || 73. img-&gt;width != w-&gt;dst_width || 74. img-&gt;height != w-&gt;dst_height)) { 75. /* save *converted* image for redraw */ 76. zprintf(48, &quot;convert: %.4s(%08x) %dx%d =&gt; %.4s(%08x) %dx%d\\n&quot;, 77. (char*)&amp;img-&gt;format, img-&gt;format, img-&gt;width, img-&gt;height, 78. (char*)&amp;w-&gt;format, w-&gt;format, w-&gt;dst_width, w-&gt;dst_height); 79. w-&gt;image = zbar_image_convert_resize(img, w-&gt;format, 80. w-&gt;dst_width, w-&gt;dst_height); 81. w-&gt;image-&gt;syms = img-&gt;syms; 82. if(img-&gt;syms) 83. zbar_symbol_set_ref(img-&gt;syms, 1); 84. zbar_image_destroy(img); 85. img = w-&gt;image; 86. } 88. if(!rc) { 89. point_t org; 90. rc = w-&gt;draw_image(w, img); 92. org = w-&gt;scaled_offset; 93. if(org.x &gt; 0) { 94. point_t p = { 0, org.y }; 95. point_t s = { org.x, w-&gt;scaled_size.y }; 96. _zbar_window_fill_rect(w, 0, p, s); 97. s.x = w-&gt;width - w-&gt;scaled_size.x - s.x; 98. if(s.x &gt; 0) { 99. p.x = w-&gt;width - s.x; 100. _zbar_window_fill_rect(w, 0, p, s); 101. } 102. } 103. if(org.y &gt; 0) { 104. point_t p = { 0, 0 }; 105. point_t s = { w-&gt;width, org.y }; 106. _zbar_window_fill_rect(w, 0, p, s); 107. s.y = w-&gt;height - w-&gt;scaled_size.y - s.y; 108. if(s.y &gt; 0) { 109. p.y = w-&gt;height - s.y; 110. _zbar_window_fill_rect(w, 0, p, s); 111. } 112. } 113. } 114. if(!rc) 115. rc = window_draw_overlay(w); 116. } 117. else 118. rc = 1; 120. if(rc) 121. rc = _zbar_window_draw_logo(w); 123. _zbar_window_end(w); 124. (void)window_unlock(w); 125. return(rc); 126.} `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 上次代码分析中提到zbar_window_draw()函数，实现了将图像输出到某一平台或界面上的功能。而这个函数实现了对最后一张图像的重新渲染，可以理解成zbar_window_draw()的进一步操作。 对比代码内容可以看出，zbar_window_redraw()相对于zbar_window_draw()增加了图像曝光部分的功能。 下面对代码中涉及的算法进行介绍。 亮度感应及曝光感光宽容度从最明亮到最黑暗，假设人眼能够看到一定的范围，那么胶片（或CCD等电子感光器件）所能表现的远比人眼看到的范围小的多，而这个有限的范围就是感光宽容度。 自动曝光和18%灰对于sensor来说，又是如何来判断曝光是否正确呢？很标准的做法就是在YUV空间计算当前图像的Y值的均值。调节各种曝光参数设定（自动或手动），使得该均值落在一个目标值附近的时候，就认为得到了正确的曝光。 那么如何确定这个Y的均值，以及如何调整参数使得sensor能够将当前图像的亮度调整到这个范围呢？ 这就涉及到一个概念 18%灰，一般认为室内室外的景物，在通常的情况下，其平均的反光系数大约为18%，而色彩均值，如前所述，可以认为是一种中灰的色调。这样，可以通过对 反光率为18%的灰板拍摄，调整曝光参数，使其颜色接近为中等亮度的灰色（Y值为128）。 gamma校正曝光的均值正确了，不代表整体图像的亮度分布就和人眼所看到的保持一致了。 事实上，人眼对亮度的响应并不是一个线性的比例关系，而各种涉及到光电转换的设备的输入输出特性曲线一般也是非线性的，且表现为幂函数的形式，所以整个图像系统的传递函数是一个幂函数： g＝g 1× g 2×…× g n 对于sensor来说，其响应倒是接近为线性关系，所以为了在各种设备上正确输出符合人眼对亮度的响应的图像，就需要进行校正。 幂函数的指数的倒数就是通常所说的gamma值。 归一化的gamma曲线 实际上，sensor在做gamma校正的时候，通常也一并作了从raw格式的10bit的数据到8bit数据的转换，所以这时候的公式可以表示为对比度。 窗口图层覆盖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192931. static inline int window_draw_overlay (zbar_window_t *w) 2. { 3. if(!w-&gt;overlay) 4. return(0); 5. if(w-&gt;overlay &gt;= 1 &amp;&amp; w-&gt;image &amp;&amp; w-&gt;image-&gt;syms) { 6. /* FIXME outline each symbol */ 7. const zbar_symbol_t *sym = w-&gt;image-&gt;syms-&gt;head; 8. for(; sym; sym = sym-&gt;next) { 9. uint32_t color = ((sym-&gt;cache_count &lt; 0) ? 4 : 2); 10. if(sym-&gt;type == ZBAR_QRCODE) 11. window_outline_symbol(w, color, sym); 12. else { 13. /* FIXME linear bbox broken */ 14. point_t org = w-&gt;scaled_offset; 15. int i; 16. for(i = 0; i &lt; sym-&gt;npts; i++) { 17. point_t p = window_scale_pt(w, sym-&gt;pts[i]); 18. p.x += org.x; 19. p.y += org.y; 20. if(p.x &lt; 3) 21. p.x = 3; 22. else if(p.x &gt; w-&gt;width - 4) 23. p.x = w-&gt;width - 4; 24. if(p.y &lt; 3) 25. p.y = 3; 26. else if(p.y &gt; w-&gt;height - 4) 27. p.y = w-&gt;height - 4; 28. _zbar_window_draw_marker(w, color, p); 29. } 30. } 31. } 32. } 34. if(w-&gt;overlay &gt;= 2) { 35. /* calculate/display frame rate */ 36. unsigned long time = _zbar_timer_now(); 37. if(w-&gt;time) { 38. int avg = w-&gt;time_avg = (w-&gt;time_avg + time - w-&gt;time) / 2; 39. point_t p = { -8, -1 }; 40. char text[32]; 41. sprintf(text, &quot;%d.%01d fps&quot;, 1000 / avg, (10000 / avg) % 10); 42. _zbar_window_draw_text(w, 3, p, text); 43. } 44. w-&gt;time = time; 45. } 46. return(0);47. } 一张完整的图像可能是由若干个大小不同的图层组成的。如果由计算机将这若干个图层渲染成一张完整的图像，则需要根据图层的z值（也可以理解为远近关系，z值越大，从视觉角度来看，图层被显现的内容越多），所以，一般渲染过程，就是将图层根据z值进行升序排序，然后从z值最小的图层开始依次渲染。每个图层都是固定大小的矩形（即使生活中我们看到各种形状的图形，它们其实是被包含到一个矩形区域”RGBA画布”中）。 图层之间的关系模型，可以看成是上层（z值大）图层依赖下层（z值小）图层。约定上层图层只能依赖下层图层（在算法实现中，上层图层只依赖了一个下层图层，目的是为了让图层之间的关系更简单），所以就不会不存在闭环，但是一个图层可以被多个上层图层依赖。 三、总结本次代码分析对Window模块的几个函数进行了说明和算法分析，如有不足，请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Window%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90-2/"},{"title":"ZBar源码分析——image.c","text":"ZBar源码分析——image.c[TOC] 一、Image 模块 ZBar的工作流程在以往的博客中做过一些介绍，在前几次的博客分析中也对video input部分和image scanner部分的一些代码进行了分析。在分析的过程中，我们发现，ZBar的Image模块起着不可或缺的作用，所有的分析和解码工作都是建立在图像的基础上完成的。 从工作流程图中我们也能看出，视频输入后，需要转换成图像的形式进行后续分析，并不是之间对视频进行处理。 在之前的博客中，也对Image模块的部分代码进行过简单介绍和分析，这篇博客将从image.c展开，对Image模块进行探索。 二、代码分析首先对zbar_image_t的结构（ZBar图像的数据结构）进行说明。这在前面的博客中提及过。 123456789101112131415161718192021222324252627282930313233343536373839 `2. struct zbar_image_s { 3. uint32_t format; /* fourcc image format code */ 4. unsigned width, height; /* image size */ 5. const void *data; /* image sample data */ 6. unsigned long datalen; /* allocated/mapped size of data */ 7. unsigned crop_x, crop_y; /* crop rectangle */ 8. unsigned crop_w, crop_h; 9. void *userdata; /* user specified data associated w/image */ 11. /* cleanup handler */ 12. zbar_image_cleanup_handler_t *cleanup; 13. refcnt_t refcnt; /* reference count */ 14. zbar_video_t *src; /* originator */ 15. int srcidx; /* index used by originator */ 16. zbar_image_t *next; /* internal image lists */ 18. unsigned seq; /* page/frame sequence number */ 19. zbar_symbol_set_t *syms; /* decoded result set */ 20. };`![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) uint32_t格式；/*fourcc图像格式代码*/ 注：FourCC全称Four-Character Codes，代表四字符代码 (four character code), 它是一个32位的标示符，其实就是typedef unsigned int FOURCC;是一种独立标示视频数据流格式的四字符代码。 视频播放软件通过查询 FourCC 代码并且寻找与 FourCC 代码相关联的视频[解码](https://so.csd器来播放特定的视频流。比如： DIV3 = DivX Low-Motion, DIV4 = DivX Fast-Motion, DIVX = DivX4, FFDS = FFDShow 等。比如wav、avi等RIFF文件的标签头标示，Quake 3的模型文件.md3中也大量存在等于“IDP3”的FOURCC。 unsigned width, height; /图像大小/ const void *data; /*图像样本数据*/ unsigned long datalen; /已分配/映射的数据大小/ unsigned crop_x, crop_y; /裁剪矩形/ unsigned crop_w, crop_h; void*userdata; /*与图像关联的用户指定数据*/ refcnt_t refcnt; /引用计数/ zbar_video_t*src; /*生成器*/ int srcidx; /生成器使用的索引/ zbar_image_t *next; /*内部图像列表*/ unsigned seq; /页/帧序列号/ zbar_symbol_set_t*syms; /*解码结果集*/ 检索、扫描并裁剪矩形1234567891011121314151617void zbar_image_set_crop (zbar_image_t *img, unsigned x, unsigned y, unsigned w, unsigned h){ unsigned img_w = img-&gt;width; if(x &gt; img_w) x = img_w; if(x + w &gt; img_w) w = img_w - x; img-&gt;crop_x = x; img-&gt;crop_w = w; unsigned img_h = img-&gt;height; if(y &gt; img_h) y = img_h; if(y + h &gt; img_h) h = img_h - y; img-&gt;crop_y = y; img-&gt;crop_h = h;} 在前面的代码分析中提到，BZar在对图像进行扫描、解码等操作时，都是基于矩形进行的。这个函数将识别得到的图像中条码附近的矩形区域进行了处理，将不包含条码的区域裁剪掉，得到需要处理的区域。 图像内存释放c1234567891011121314151617181920212223242526272829303132inline void zbar_image_free_data (zbar_image_t *img){ if(!img) return; if(img-&gt;src) { zbar_image_t *newimg; /* replace video image w/new copy */ assert(img-&gt;refcnt); /* FIXME needs lock */ newimg = zbar_image_create(); memcpy(newimg, img, sizeof(zbar_image_t)); /* recycle video image */ newimg-&gt;cleanup(newimg); /* detach old image from src */ img-&gt;cleanup = NULL; img-&gt;src = NULL; img-&gt;srcidx = -1; } else if(img-&gt;cleanup &amp;&amp; img-&gt;data) { if(img-&gt;cleanup != zbar_image_free_data) { /* using function address to detect this case is a bad idea; * windows link libraries add an extra layer of indirection... * this works around that problem (bug #2796277) */ zbar_image_cleanup_handler_t *cleanup = img-&gt;cleanup; img-&gt;cleanup = zbar_image_free_data; cleanup(img); } else free((void*)img-&gt;data); } img-&gt;data = NULL;} 接下来分析的函数负责释放图像内存。首先注意到，这个函数是内联函数。 内联函数 在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。 为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。 栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 ZBar项目中特地将释放图像内存的函数声明为内联函数，说明该函数在ZBar项目的运行过程中将被频繁调用，换言之，ZBar的运行过程中将频繁对图像进行创建和释放。这也在某种程度上体现了Image模块对ZBar项目的重要性。 回到函数本身，在释放图像内存时，首先判断当前图像是否处在一个视频文件的逐帧迭代中（由src属性确定），如果是，则更换带有新副本的视频图像，将下一帧图像需要的资源进行内存拷贝，并对当前图像的索引进行重置。如果当前图像并不处在一个视频文件的逐帧迭代中，或是以及完成迭代，则检查其中关联的数据是否被释放，如果未被释放，则需要先释放这些数据，否则会产生空指针异常。这些检查工作完成后，方可释放图像内存。 值得一提的是，上述函数中提及了memcpy()函数： 函数原型为：*void *memcpy(void *destin, void source, unsigned n); 参数： destin-- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 source-- 指向要复制的数据源，类型强制转换为 void* 指针。 n-- 要被复制的字节数。 该函数返回一个指向目标存储区destin的指针。 它实现了从源source所指的内存地址的起始位置开始拷贝n个字节到目标destin所指的内存地址的起始位置中。 图像写入文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455typedef struct zimg_hdr_s { uint32_t magic, format; uint16_t width, height; uint32_t size;} zimg_hdr_t;int zbar_image_write (const zbar_image_t *img, const char *filebase){ int len = strlen(filebase) + 16; char *filename = malloc(len); int n = 0, rc = 0; FILE *f; zimg_hdr_t hdr; strcpy(filename, filebase); if((img-&gt;format &amp; 0xff) &gt;= ' ') n = snprintf(filename, len, &quot;%s.%.4s.zimg&quot;, filebase, (char*)&amp;img-&gt;format); else n = snprintf(filename, len, &quot;%s.%08&quot; PRIx32 &quot;.zimg&quot;, filebase, img-&gt;format); assert(n &lt; len - 1); filename[len - 1] = '\\0'; zprintf(1, &quot;dumping %.4s(%08&quot; PRIx32 &quot;) image to %s\\n&quot;, (char*)&amp;img-&gt;format, img-&gt;format, filename); f = fopen(filename, &quot;w&quot;); if(!f) {#ifdef HAVE_ERRNO_H rc = errno; zprintf(1, &quot;ERROR opening %s: %s\\n&quot;, filename, strerror(rc));#else rc = 1;#endif goto error; } hdr.magic = 0x676d697a; hdr.format = img-&gt;format; hdr.width = img-&gt;width; hdr.height = img-&gt;height; hdr.size = img-&gt;datalen; if(fwrite(&amp;hdr, sizeof(hdr), 1, f) != 1 || fwrite(img-&gt;data, 1, img-&gt;datalen, f) != img-&gt;datalen) {#ifdef HAVE_ERRNO_H rc = errno; zprintf(1, &quot;ERROR writing %s: %s\\n&quot;, filename, strerror(rc));#else rc = 1;#endif fclose(f); goto error; } rc = fclose(f);error: free(filename); return(rc);} 对ZBar工作流程进行简单分析可以得知，ZBar对图像进行获取后，会在内存中以临时文件的形式进行保存，便于后续扫描器和解码器的使用。 在实现该函数时，首先声明了图像的渲染格式，即 zimg_hdr_s，所有的图像都会以该数据结构规整后的格式存入。代码中将渲染格式中的magic属性规定为0x676d697a，这也许是图像的统一色调。 该函数开始时，对图像文件创建一份副本，副本的文件大小=原文件大小+16。这是为了防止在后续的处理过程中，对图像文件进行了增量而导致申请的内存不够出现数据丢失的问题。 该函数的后续处理较为简单，通过几个分支对不同格式的图像进行分类保存。 三、总结本次博客对ZBar扫描器的Image模块的几个关键函数进行了分析，也是对Video模块的一些补充说明。如有不足，敬请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94image-c/"},{"title":"ZBar源码分析——img_scanner.c","text":"ZBar源码分析——img_scanner.c一、ZBar的工作流程 通过分析ZBar项目的结构，可以看到ZBar的工作流程大致分为4个步骤： （一）读入图像并配置参数； （二）扫描读入的图像并根据梯度变化分析其明暗宽度流（根据明暗宽度流可以得出读入图像中的条码类型，如：二维码，code93，code128等）； （三）分析读入图像的像素点及其特征； （四）找到条码格式信息并解码，最后输出恢复出来的码字。 二、Image ScannerImage Scanner，顾名思义是实现对读入图像进行扫描的功能模块。本次要分析的scanner.c就是这一功能模块的核心之一。 ZBar实现Image Scanner的核心主要由img_scanner.c和scanner.c两个文件组成。 其中，img_scanner.c中的核心函数是zbar_scan_image()，而scanner.c中的核心函数是zbar_scan_y()。经过简单分析得到，zbar_scan_image主要负责ZBar对读入图像的扫描工作，函数主要根据设定的扫描密度(density)控制像素点读取(按Z字形读取，这也是ZBar名称的由来)，scanner.c文件内的zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 zbar_scan_image()的实现需要借助zbar_scan_y()扫描图像形成宽度流的结果。 三、img_scanner.c本次源码分析主要对img_scanner.c文件进行分析（主要分析zbar_scan_image()函数）。 zbar_image_scanner_create() 创建（安装）图片扫描器Image Scanner并将其应用于解码以及各类条码的识别。 1234567891011121314151617181920212223242526272829303132333435 //创建图片扫描器的函数实现 zbar_image_scanner_t *zbar_image_scanner_create () { zbar_image_scanner_t *iscn = calloc(1, sizeof(zbar_image_scanner_t)); //若创建失败，返回NULL if(!iscn) return(NULL); //初始化图片扫描器（初始化图片扫描器中的解码器和扫描器） iscn-&gt;dcode = zbar_decoder_create(); iscn-&gt;scn = zbar_scanner_create(iscn-&gt;dcode);//若解码器或扫描器初始化失败，返回NULL if(!iscn-&gt;dcode || !iscn-&gt;scn) { zbar_image_scanner_destroy(iscn); return(NULL); }//将图片扫描器应用于解码器 zbar_decoder_set_userdata(iscn-&gt;dcode, iscn); zbar_decoder_set_handler(iscn-&gt;dcode, symbol_handler);#ifdef ENABLE_QRCODE iscn-&gt;qr = _zbar_qr_create();#endif//将图片扫描器应用于各类条码的识别 CFG(iscn, ZBAR_CFG_X_DENSITY) = 1; CFG(iscn, ZBAR_CFG_Y_DENSITY) = 1; zbar_image_scanner_set_config(iscn, 0, ZBAR_CFG_POSITION, 1); zbar_image_scanner_set_config(iscn, 0, ZBAR_CFG_UNCERTAINTY, 2); zbar_image_scanner_set_config(iscn, ZBAR_QRCODE, ZBAR_CFG_UNCERTAINTY, 0); zbar_image_scanner_set_config(iscn, ZBAR_CODE128, ZBAR_CFG_UNCERTAINTY, 0); zbar_image_scanner_set_config(iscn, ZBAR_CODE93, ZBAR_CFG_UNCERTAINTY, 0); zbar_image_scanner_set_config(iscn, ZBAR_CODE39, ZBAR_CFG_UNCERTAINTY, 0); zbar_image_scanner_set_config(iscn, ZBAR_CODABAR, ZBAR_CFG_UNCERTAINTY, 1); zbar_image_scanner_set_config(iscn, ZBAR_COMPOSITE, ZBAR_CFG_UNCERTAINTY, 0); return(iscn);} 当需要卸载Image Scanner时，不能直接free(img_scanner)释放内存空间，这会直接导致ZBar扫描器zbar_scanner、ZBar解码器zbar_decoder以及各类条码识别应用发生空指针异常。因此需要先判断Image Scanner在各个部件和应用上的使用情况，若正在使用，则需要先解除Image Scanner的应用，最后才能直接释放内存。 1234567891011121314151617181920212223242526272829303132333435363738 //图片扫描器的卸载 void zbar_image_scanner_destroy (zbar_image_scanner_t *iscn) { int i; dump_stats(iscn); //判断图片扫描器的状态，若处于应用状态，则不可卸载 if(iscn-&gt;syms) { if(iscn-&gt;syms-&gt;refcnt) zbar_symbol_set_ref(iscn-&gt;syms, -1); else _zbar_symbol_set_free(iscn-&gt;syms); iscn-&gt;syms = NULL; }//判断图片扫描器是否应用于ZBar扫描器，如果是，则从ZBar扫描器上卸载 if(iscn-&gt;scn) zbar_scanner_destroy(iscn-&gt;scn); iscn-&gt;scn = NULL;判断图片扫描器是否应用于ZBar解码器，如果是，则从ZBar解码器上卸载 if(iscn-&gt;dcode) zbar_decoder_destroy(iscn-&gt;dcode); iscn-&gt;dcode = NULL;//将图片扫描器从各类条码的识别应用上卸载 for(i = 0; i &lt; RECYCLE_BUCKETS; i++) { zbar_symbol_t *sym, *next; for(sym = iscn-&gt;recycle[i].head; sym; sym = next) { next = sym-&gt;next; _zbar_symbol_free(sym); } }#ifdef ENABLE_QRCODE if(iscn-&gt;qr) { _zbar_qr_destroy(iscn-&gt;qr); iscn-&gt;qr = NULL; }#endif free(iscn);} 下面是对zbar_scan_image()部分代码片段的分析： zbar_scan_image()主要实现了Z字形扫描图像密度，核心思想是通过扫描密度(density)来控制像素点读取。 函数分为从横向和纵向扫描图像两个部分，实现逻辑相差不大，下面给出纵向扫描部分的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950density = CFG(iscn, ZBAR_CFG_Y_DENSITY); if(density &gt; 0) { const uint8_t *p = data; int x = 0, y = 0; int border = (((img-&gt;crop_h - 1) % density) + 1) / 2; if(border &gt; img-&gt;crop_h / 2) border = img-&gt;crop_h / 2; border += img-&gt;crop_y; assert(border &lt;= h); svg_group_start(&quot;scanner&quot;, 0, 1, 1, 0, 0); iscn-&gt;dy = 0; movedelta(img-&gt;crop_x, border); iscn-&gt;v = y; while(y &lt; cy1) { int cx0 = img-&gt;crop_x;; zprintf(128, &quot;img_x+: %04d,%04d @%p\\n&quot;, x, y, p); svg_path_start(&quot;vedge&quot;, 1. / 32, 0, y + 0.5); iscn-&gt;dx = iscn-&gt;du = 1; iscn-&gt;umin = cx0; while(x &lt; cx1) { uint8_t d = *p; movedelta(1, 0); zbar_scan_y(scn, d); } ASSERT_POS; quiet_border(iscn); svg_path_end(); movedelta(-1, density); iscn-&gt;v = y; if(y &gt;= cy1) break; zprintf(128, &quot;img_x-: %04d,%04d @%p\\n&quot;, x, y, p); svg_path_start(&quot;vedge&quot;, -1. / 32, w, y + 0.5); iscn-&gt;dx = iscn-&gt;du = -1; iscn-&gt;umin = cx1; while(x &gt;= cx0) { uint8_t d = *p; movedelta(-1, 0); zbar_scan_y(scn, d); } ASSERT_POS;c quiet_border(iscn); svg_path_end(); movedelta(1, density); iscn-&gt;v = y; } svg_group_end(); } iscn-&gt;dx = 0; 这部分代码主要实现了纵向扫描图像密度，由于其中调用函数关系较为复杂，若只看坐标部分，可简化为以下代码： 12345678910111213141516171819202122232425262728 //先判断有没有设定y密度 if(ydensity &gt; 0) { while(y &lt; h) //y从0以ydensity递增到h { while(x &lt; w) //x先从0递增到w，再递减回0 { x += 1; zbar_scan_y(); } x = w - 1; y = y + ydensity //y从0以ydensity递增到h if(y &gt;= h) break; while(x &gt;= 0)// x开始递减 {c x -= 1; zbar_scan_y(); } x = 0 + 1; y = y + ydensity; }//接着判断x方向扫描密度,同理Z字形扫描} 12w = img-&gt;width;h = img-&gt;height; 以上代码中w表示图像宽度，h表示图像高度，函数在循环过程中反复调用zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 根据代码进行绘制，大致能得到ZBar扫描图像像素的顺序大致如下： 以上便是本次的代码分析报告，如有错误，请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94img-scanner-c/"},{"title":"ZBar源码分析——scanner.c_2","text":"[TOC] 一、Image ScannerImage Scanner是ZBar实现对读入图像进行扫描的功能模块。Image Scanner的核心主要由img_scanner.c和scanner.c两个文件组成。 其中，img_scanner.c中的核心函数是zbar_scan_image()，而scanner.c中的核心函数是zbar_scan_y()。经过简单分析得到，zbar_scan_image主要负责ZBar对读入图像的扫描工作，函数主要根据设定的扫描密度(density)控制像素点读取(按Z字形读取，这也是ZBar名称的由来)，scanner.c文件内的zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 上次博客分析了scanner.c中的ZBar扫描器的内存分配以及图像的边界判断（包括差分的运算和应用），这次博客继续分析关于阈值的计算等内容。 二、小波阈值去噪图像噪声噪声可以理解为“妨碍人们感觉器官对所接收的信源信息理解的因素”。 例如，一幅黑白图片，其平面亮度分布假定为f(x，y)，那么对其接收起干扰作用的亮度分布R(x，y)，即可称为图像噪声。 但是，噪声在理论上可以定义为“不可预测，只能用概率统计方法来认识的随机误差”。因此将图像噪声看成是多维随机过程是合适的，因而描述噪声的方法完全可以借用随机过程的描述，即用其概率分布函数和概率密度分布函数。 理论依据图像和噪声在经过小波变换后具有不同的特性，因为将含噪信号在各尺度上进行小波分解后，图像的能量主要集中在低分辨率子带上，而噪声信号的能量主要分布在各个高频子带上。 原始图像信息的小波系数绝对值较大，噪声信息小波系数的绝对值较小，在这种前提下，我们可以通过设定一个合适的阈值门限，采用阈值办法保留有用信号系数。而且这个去噪的过程其实也就是对高频的小波系数进行处理的过程。 去噪过程如下图： 阈值去噪硬阈值去噪当小波系数小于某个临界阈值时，认为当时的小波系数主要是由噪声引起的，应该舍弃；当小波系数大于这个临界阈值时，认为这时的小波系数主要是由信号引起的，应该把小波系数直接保留下来。 软阈值去噪进行比较含噪信号的小波系数与选定的阈值大小，大于阈值的点收缩为该点值与阈值的差值，小于阈值相反数的点收缩为该点值与阈值的和，绝对值小于等于阈值的点为0。 阈值选择阈值的确定在阈值萎缩中是最关键的。 目前使用的阈值可以分成全局阈值和局部适应阈值两类。 其中，全局阈值对各层所有的小波系数或同一层内的小波系数都是统一的；而局部适应阈值是根据当前系数周围的局部情况来确定阈值。目前提出的全局阈值主要有以下几种： （1）Donoho和Johastone统一阈值（简称DJ阈值）： PS：σ为噪声标准方差，N为信号的尺寸或长度 （2）基于零均值正态分布的置信区间阈值： （3）Bayes Shrink阈值和Map Shrink阈值。在小波系数服从广义高斯分布的假设下，Chang等人得出了阈值： PS：R为噪声标准方差，RB为广义高斯分布的标准方差值 （4）最小最大化阈值：这是Donoho和John Stone在最小最大化意义下得出的阈值，与上述的阈值不同，它是依赖于信号的，而且没有显式表达式，在求取时需要预先知道原信号。 （5）理想阈值：理想阈值是在均方差准则下的最优阈值，同最大最小化阈值一样，也没有显式的表达式，并且这个阈值的计算通常也需先知道信号本身。 三、scanner.c中的阈值计算12345678910111213141516171819202122232425 static inline unsigned calc_thresh (zbar_scanner_t *scn) { /* threshold 1st to improve noise rejection */ unsigned dx, thresh = scn-&gt;y1_thresh; unsigned long t; if((thresh &lt;= scn-&gt;y1_min_thresh) || !scn-&gt;width) { dbprintf(1, &quot; tmin=%d&quot;, scn-&gt;y1_min_thresh); return(scn-&gt;y1_min_thresh); } /* slowly return threshold to min */ dx = (scn-&gt;x &lt;&lt; ZBAR_FIXED) - scn-&gt;last_edge; t = thresh * dx; t /= scn-&gt;width; t /= ZBAR_SCANNER_THRESH_FADE; dbprintf(1, &quot; thr=%d t=%ld x=%d last=%d.%d (%d)&quot;, thresh, t, scn-&gt;x, scn-&gt;last_edge &gt;&gt; ZBAR_FIXED, scn-&gt;last_edge &amp; ((1 &lt;&lt; ZBAR_FIXED) - 1), dx); if(thresh &gt; t) { thresh -= t; if(thresh &gt; scn-&gt;y1_min_thresh) return(thresh); } scn-&gt;y1_thresh = scn-&gt;y1_min_thresh; return(scn-&gt;y1_min_thresh);} 关于小波变换等处理在process.c文件中给出，由其他组员负责分析。 ZBar采用的算法是上述提到的（最大）最小化阈值，即在预先知道原信号的情况下，在最小（最大）化意义下得出的阈值。 首先对信号进行一阶差分，在此基础上，对一阶差分计算阈值，有利于去噪。 取得扫描器结构中的阈值，如果当前阈值小于最小阈值，或者边缘宽度为0，则返回最小阈值。 接下来求相对阈值。 相对阈值 = 上一次的阈值 * 当前边缘和上一次边缘之间的距离 / 再上一个距离的比值 如果上一次的阈值大于相对阈值，则用上一次的阈值减去相对阈值，结果如果大于最小阈值，则返回这个结果，否则返回最小阈值。 四、边界处理123456789101112131415161718192021 static inline zbar_symbol_type_t process_edge (zbar_scanner_t *scn, int y1) { if(!scn-&gt;y1_sign) scn-&gt;last_edge = scn-&gt;cur_edge = (1 &lt;&lt; ZBAR_FIXED) + ROUND; else if(!scn-&gt;last_edge) scn-&gt;last_edge = scn-&gt;cur_edge; scn-&gt;width = scn-&gt;cur_edge - scn-&gt;last_edge; dbprintf(1, &quot; sgn=%d cur=%d.%d w=%d (%s)\\n&quot;, scn-&gt;y1_sign, scn-&gt;cur_edge &gt;&gt; ZBAR_FIXED, scn-&gt;cur_edge &amp; ((1 &lt;&lt; ZBAR_FIXED) - 1), scn-&gt;width, ((y1 &gt; 0) ? &quot;SPACE&quot; : &quot;BAR&quot;)); scn-&gt;last_edge = scn-&gt;cur_edge;#if DEBUG_SVG &gt; 1 svg_path_moveto(SVG_ABS, scn-&gt;last_edge - (1 &lt;&lt; ZBAR_FIXED) - ROUND, 0);#endif /* pass to decoder */ if(scn-&gt;decoder) return(zbar_decode_width(scn-&gt;decoder, scn-&gt;width)); return(ZBAR_PARTIAL);} process_edge函数对满足边界判定规则的点进行边缘处理。 上篇博客提到，ZBar边缘判定规则是根据二阶导数（y1_sign，即最后一个斜坡的坡度)为零的位置是一阶时的最大值或最小值，认为是边缘点。而last_edge是最后定位的边的插值位置。 ZBar扫描图像，对于每一个元素，若当前扫描位置不是元素的边缘点，则继续往下扫描（Z字型扫描）；若遇到边缘点，则判断是否在当前扫描元素的最外沿（根据last_edge是否在最后定位的边的插值位置）。直到找到符合上述两个条件的位置，继续向下执行。 找到边界后，将最外沿位置与另一端位置相减，得到元素的宽度。然后将cur_edge赋值给last_edge，准备扫描下一个元素。 最后还需要将元素宽度传给解码器进行解码处理。 1234567if(scn-&gt;cur_edge != x || scn-&gt;y1_sign &gt; 0) { zbar_symbol_type_t edge = process_edge(scn, -scn-&gt;y1_sign); dbprintf(1, &quot;flush0:&quot;); scn-&gt;cur_edge = x; scn-&gt;y1_sign = -scn-&gt;y1_sign; return(edge); } 另一方面，在zbar_scanner_flush()函数中，调用了边界处理函数。 在每次刷新扫描器时，需要对已经处理过边界的元素进行初始化，这里处理得很巧妙的是将y1_sign的相反数赋值给y1_sign，即取其二阶导数的相反数。 五、更新边界线性插值算法算法内容线性插值是指插值函数为一次多项式的插值方式，其在插值节点上的插值误差为零。线性插值可以用来近似代替原函数，也可以用来计算得到查表过程中表中没有的数值。 插值在图像处理中的应用在播放视频时，常遇到视频尺寸与画布尺寸不一致的情况。为了让视频按比例填充画布，需要对视频中的每一帧图像做缩放处理。 插值前 插值后 假设源图像大小为mxn，目标图像为axb。那么两幅图像的边长比分别为：m/a和n/b。注意，通常这个比例不是整数，编程存储的时候要用浮点型。目标图像的第（i,j）个像素点（i行j列）可以通过边长比对应回源图像。其对应坐标为（i*m/a,j*n/b）。显然，这个对应坐标一般来说不是整数，而非整数的坐标是无法在图像这种离散数据上使用的。双线性插值通过寻找距离这个对应坐标最近的四个像素点，来计算该点的值（灰度值或者RGB值）。如果你的对应坐标是（2.5,4.5），那么最近的四个像素是（2，4）、（2，5）、（3，4），（3，5）。若图像为灰度图像，那么（i，j）点的灰度值可以通过一下公式计算：f(i,j)=w1*p1+w2*p2+w3*p3+w4*p4;其中，pi(i=1,2,3,4)为最近的四个像素点，wi(i=1,2,3,4)为各点相应权值。 123456789101112131415161718inline zbar_symbol_type_t zbar_scanner_flush (zbar_scanner_t *scn) { unsigned x; if(!scn-&gt;y1_sign) return(ZBAR_NONE); x = (scn-&gt;x &lt;&lt; ZBAR_FIXED) + ROUND; if(scn-&gt;cur_edge != x || scn-&gt;y1_sign &gt; 0) { zbar_symbol_type_t edge = process_edge(scn, -scn-&gt;y1_sign); dbprintf(1, &quot;flush0:&quot;); scn-&gt;cur_edge = x; scn-&gt;y1_sign = -scn-&gt;y1_sign; return(edge); } scn-&gt;y1_sign = scn-&gt;width = 0; if(scn-&gt;decoder) return(zbar_decode_width(scn-&gt;decoder, 0)); return(ZBAR_PARTIAL);} ZBar通过线性插值算法获得新的边界： 首先更新阈值，然后对运动均值后的图像一阶差分，然后乘以一个常数，得到插值结果，即新的边界。 六、总结本次博客对ZBar扫描器的图像阈值计算、边界判断、边界重置等算法进行了分析。如有不足，敬请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94scanner-c-2/"},{"title":"ZBar源码分析——video.c_1","text":"[TOC] 一、Video模块我们知道，扫描时提供给ZBar的不都是静态的图片，也有可能是动态的视频。例如我们日常生活中调用的微信扫码，所提供的也是视频video，这时便需要Zbar对视频进行分析，动态扫码。 Video模块是ZBar实现对读入视频进行扫描分析的功能模块。核心代码由video.h和video.c组成，video.h包括对一些关键变量的声明和结构体的定义，同时也是其他部件对Video模块的调用接口（头文件），而具体功能代码则是在video.c中实现。 二、代码分析在ZBar项目，每一个功能部件的实现通常都会有对这个部件的初始化、增加、释放内存等函数，这与Java中的new一个对象以及set()，get()函数有异曲同工之妙。 12345678910111213141516171819202122232425262728291. static void _zbar_video_recycle_image (zbar_image_t *img) 2. { 3. zbar_video_t *vdo = img-&gt;src; 4. assert(vdo); 5. assert(img-&gt;srcidx &gt;= 0); 6. video_lock(vdo); 7. if(vdo-&gt;images[img-&gt;srcidx] != img) 8. vdo-&gt;images[img-&gt;srcidx] = img; 9. if(vdo-&gt;active) 10. vdo-&gt;nq(vdo, img); 11. else 12. video_unlock(vdo); 13. } Video模块也不例外，首先分析_zbar_video_recycle_image (zbar_image_t *img)函数，顾名思义，这是Video模块对输入视频的图像进行逐帧循环的函数。 在分析这个函数之前，这里先对zbar_image_t的结构进行补充说明。 123456789101112131415161718192021222324252627282930313233343536373839 `2. struct zbar_image_s { 3. uint32_t format; /* fourcc image format code */ 4. unsigned width, height; /* image size */ 5. const void *data; /* image sample data */ 6. unsigned long datalen; /* allocated/mapped size of data */ 7. unsigned crop_x, crop_y; /* crop rectangle */ 8. unsigned crop_w, crop_h; 9. void *userdata; /* user specified data associated w/image */ 11. /* cleanup handler */ 12. zbar_image_cleanup_handler_t *cleanup; 13. refcnt_t refcnt; /* reference count */ 14. zbar_video_t *src; /* originator */ 15. int srcidx; /* index used by originator */ 16. zbar_image_t *next; /* internal image lists */ 18. unsigned seq; /* page/frame sequence number */ 19. zbar_symbol_set_t *syms; /* decoded result set */ 20. };`![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) uint32_t格式；/*fourcc图像格式代码*/ 注：FourCC全称Four-Character Codes，代表四字符代码 (four character code), 它是一个32位的标示符，其实就是typedef unsigned int FOURCC;是一种独立标示视频数据流格式的四字符代码。 视频播放软件通过查询 FourCC 代码并且寻找与 FourCC 代码相关联的视频解码器来播放特定的视频流。比如： DIV3 = DivX Low-Motion, DIV4 = DivX Fast-Motion, DIVX = DivX4, FFDS = FFDShow 等。比如wav、avi等RIFF文件的标签头标示，Quake 3的模型文件.md3中也大量存在等于“IDP3”的FOURCC。 unsigned width, height；/图像大小/ const void *data；/*图像样本数据*/ unsigned long datalen; /已分配/映射的数据大小/ unsigned crop_x, crop_y; /裁剪矩形/ unsigned crop_w, crop_h; void*userdata；/*与图像关联的用户指定数据*/ refcnt_t refcnt；/引用计数/ zbar_video_t*src；/*生成器*/ int srcidx；/生成器使用的索引/ zbar_image_t *next；/*内部图像列表*/ unsigned seq；/页/帧序列号/ zbar_symbol_set_t*syms；/*解码结果集*/ 以及对zbar_video_s传入视频结构体的结构进行补充。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384`1. struct zbar_video_s { 2. errinfo_t err; /* error reporting */ 3. int fd; /* open camera device */ 4. unsigned width, height; /* video frame size */ 6. video_interface_t intf; /* input interface type */ 7. video_iomode_t iomode; /* video data transfer mode */ 8. unsigned initialized : 1; /* format selected and images mapped */ 9. unsigned active : 1; /* current streaming state */ 11. uint32_t format; /* selected fourcc */ 12. unsigned palette; /* v4l1 format index corresponding to format */ 13. uint32_t *formats; /* 0 terminated list of supported formats */ 15. unsigned long datalen; /* size of image data for selected format */ 16. unsigned long buflen; /* total size of image data buffer */ 17. void *buf; /* image data buffer */ 19. unsigned frame; /* frame count */ 21. zbar_mutex_t qlock; /* lock image queue */ 22. int num_images; /* number of allocated images */ 23. zbar_image_t **images; /* indexed list of images */ 24. zbar_image_t *nq_image; /* last image enqueued */ 25. zbar_image_t *dq_image; /* first image to dequeue (when ordered) */ 26. zbar_image_t *shadow_image; /* special case internal double buffering */ 28. video_state_t *state; /* platform/interface specific state */ 30. #ifdef HAVE_LIBJPEG 31. struct jpeg_decompress_struct *jpeg; /* JPEG decompressor */ 32. zbar_image_t *jpeg_img; /* temporary image */ 33. #endif 35. /* interface dependent methods */ 36. int (*init)(zbar_video_t*, uint32_t); 37. int (*cleanup)(zbar_video_t*); 38. int (*start)(zbar_video_t*); 39. int (*stop)(zbar_video_t*); 40. int (*nq)(zbar_video_t*, zbar_image_t*); 41. zbar_image_t* (*dq)(zbar_video_t*); 42. }; `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 在_zbar_video_recycle_image (zbar_image_t *img)函数中，还调用了assert断言函数。 简单地讲，断言就是对某种假设条件进行检查。在 C 语言中，断言被定义为宏的形式（assert(expression)），而不是函数，其原型定义在&lt;assert.h&gt;文件中。其中，assert 将通过检查表达式 expression 的值来决定是否需要终止执行程序。也就是说，如果表达式 expression 的值为假（即为 0），那么它将首先向标准错误流 stderr 打印一条出错信息，然后再通过调用 abort 函数终止程序运行；否则，assert 无任何作用。默认情况下，assert 宏只有在 Debug 版本（内部调试版本）中才能够起作用，而在 Release 版本（发行版本）中将被忽略。 在对视频的逐帧图像进行循环时，我们可以看到，ZBar进行了一系列的判断工作来保证程序可靠性。首先在锁定每一帧图像时，需要判断当前视频对象是否存在以及判断当前锁定图像的索引，若不符合要求，则断言函数会终止程序运行。 锁定某一图像后，则对这个图像进行赋值和预处理，然后解锁。 下面是video.h中对图像进行锁定、解锁和预处理的函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384`1. /* video.next_image and video.recycle_image have to be thread safe 2. * wrt/other apis 3. */ 4. static inline int video_lock (zbar_video_t *vdo) 5. { 6. int rc = 0; 7. if((rc = _zbar_mutex_lock(&amp;vdo-&gt;qlock))) { 8. err_capture(vdo, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 9. &quot;unable to acquire lock&quot;); 10. vdo-&gt;err.errnum = rc; 11. return(-1); 12. } 13. return(0); 14. } 16. static inline int video_unlock (zbar_video_t *vdo) 17. { 18. int rc = 0; 19. if((rc = _zbar_mutex_unlock(&amp;vdo-&gt;qlock))) { 20. err_capture(vdo, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 21. &quot;unable to release lock&quot;); 22. vdo-&gt;err.errnum = rc; 23. return(-1); 24. } 25. return(0); 26. } 28. static inline int video_nq_image (zbar_video_t *vdo, 29. zbar_image_t *img) 30. { 31. /* maintains queued buffers in order */ 32. img-&gt;next = NULL; 33. if(vdo-&gt;nq_image) 34. vdo-&gt;nq_image-&gt;next = img; 35. vdo-&gt;nq_image = img; 36. if(!vdo-&gt;dq_image) 37. vdo-&gt;dq_image = img; 38. return(video_unlock(vdo)); 39. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 在对图像进行锁定和解锁时，都必须保证线程安全，即不允许出现互斥情况，即有一张图像以上同时进入临界区。简言之，就是同一个视频流中，不允许多张图像被锁定。 而 video_nq_image (zbar_video_t *vdo, zbar_image_t *img)则是负责对图像进行预处理，即进行循环的简单处理。它的工作主要包括，将上一张被锁定的图像所占用的资源交给下一张即将被锁定的图像。 12345678910111213141516171819202122231. static void _zbar_video_recycle_shadow (zbar_image_t *img) 2. { 3. zbar_video_t *vdo = img-&gt;src; 4. assert(vdo); 5. assert(img-&gt;srcidx == -1); 6. video_lock(vdo); 7. img-&gt;next = vdo-&gt;shadow_image; 8. vdo-&gt;shadow_image = img; 9. video_unlock(vdo); 10. } 在对视频的处理过程中，不仅需要对图像进行逐帧循环，对视频中的阴影部分也需要逐帧处理，用于筛选出有用的扫码区域。 对阴影部分的处理逻辑与_zbar_video_recycle_image (zbar_image_t *img)函数的逻辑大致相同，需要利用断言函数判断当前传入视频图像是否存在以及对图像的下标进行合理性判断，之后对阴影区域进行锁定、循环处理和解锁操作。 三、总结本次博客对ZBar扫描器的Video模块的几个关键函数进行了分析。如有不足，敬请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94video-c-1/"},{"title":"ZBar源码分析——scanner.c_1","text":"ZBar源码分析——scanner.c（一）[TOC] 一、Image ScannerImage Scanner是ZBar实现对读入图像进行扫描的功能模块。Image Scanner的核心主要由img_scanner.c和scanner.c两个文件组成。 其中，img_scanner.c中的核心函数是zbar_scan_image()，而scanner.c中的核心函数是zbar_scan_y()。经过简单分析得到，zbar_scan_image主要负责ZBar对读入图像的扫描工作，函数主要根据设定的扫描密度(density)控制像素点读取(按Z字形读取，这也是ZBar名称的由来)，scanner.c文件内的zbar_scan_y()来完成滤波，阈值，确定边缘，转化成宽度流。 上次博客分析了img_scanner.c的主要代码，这次博客则主要分析scanner.c的主要代码。 二、scanner.c扫描器结构体组成zbar_scanner_s1234567891011 struct zbar_scanner_s { zbar_decoder_t *decoder; /* associated bar width decoder */ unsigned y1_min_thresh; /* minimum threshold */ unsigned x; /* relative scan position of next sample */ int y0[4]; /* short circular buffer of average intensities */ int y1_sign; /* slope at last crossing */ unsigned y1_thresh; /* current slope threshold */ unsigned cur_edge; /* interpolated position of tracking edge */ unsigned last_edge; /* interpolated position of last located edge */ unsigned width; /* last element width */}; zbar_scanner_s是扫描器结构体变量，由解码器和一系列图像参数变量（边界、宽度流等）组成。 zbar_decoder_t *decoder; /* 对应条宽解码器 */c unsigned y1_min_thresh; /* 最小阈值*/ unsigned x; /* 下一个样本的相对扫描位置 */ int y0[4]; /* 平均强度的短循环缓冲区 */ int y1_sign; /* 最后一个扫描节点的“坡度”（用于判断亮暗） */ unsigned y1_thresh; /* 当前“坡度”阈值 */ unsigned cur_edge; /* 跟踪边的插值位置 */ unsigned last_edge; /* 最后定位边的插值位置 */ unsigned width; /* 最后元素宽度 */ 扫描器的创建与释放123456789101112131415161718192021222324252627zbar_scanner_t *zbar_scanner_create (zbar_decoder_t *dcode) { //设定内存分配大小 zbar_scanner_t *scn = malloc(sizeof(zbar_scanner_t)); //初始化，全局变量赋值 scn-&gt;decoder = dcode; scn-&gt;y1_min_thresh = ZBAR_SCANNER_THRESH_MIN; //调用函数，重置扫描器 zbar_scanner_reset(scn); return(scn);}void zbar_scanner_destroy (zbar_scanner_t *scn){ free(scn);//由于扫描器的初始化没有应用于其他组件，可以直接释放}zbar_symbol_type_t zbar_scanner_reset (zbar_scanner_t *scn){//初始化扫描器内存，调用memset函数为&amp;scn-&gt;x申请内存空间 memset(&amp;scn-&gt;x, 0, sizeof(zbar_scanner_t) - offsetof(zbar_scanner_t, x)); scn-&gt;y1_thresh = scn-&gt;y1_min_thresh;//若当前扫描器已调用解码器，重置解码器 if(scn-&gt;decoder) zbar_decoder_reset(scn-&gt;decoder); return(ZBAR_NONE);} zbar_scanner_reset函数中提及的menset函数是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。 1void *memset(void *s, int ch, size_t n); 函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。 实际应用：将扫描器结构中x（下一个样本相对扫描位置）后面的x所需要的内存空间清空，即申请所需内存。 1offsetof(type, member-designator); C 库宏 offsetof(type, member-designator) 会生成一个类型为 size_t 的整型常量，它是一个结构成员相对于结构开头的字节偏移量。成员是由 member-designator 给定的，结构的名称是在 type 中给定的。 此处sizeof(zbar_scanner_t) - offsetof(zbar_scanner_t, x))获得的即为x所需内存空间。 差分运算差分（difference）又名差分函数或差分运算，差分的结果反映了离散量之间的c一种变化，是研究离散数学的一种工具。它将原函数f(x) 映射到f(x+a)-f(x+b) 。差分运算，相应于微分运算，是微积分中重要的一个概念。总而言之，差分对应离散，微分对应连续。 在社会经济活动与自然科学研究中,我们经常遇到与时间t有关的变量,而人们往往又只能观察或记录到这些变量在离散的t时的值。对于这类变量,如何去研究它们的相互关系,就离不开差分与差分方程的工具。微积分中的微分与微分方程的工具,事实上来源于差分与差分方程.因此差分与差分方程更是原始的客观的生动的材料。 读者熟悉等差数列：a1 a2 a3……an……，其中an+1= an + d（ n = 1,2,…n ）d为常数，称为公差， 即 d = an+1 -an , 这就是一个差分, 通常用D(an) = an+1- an来表示，于是有D(an)= d , 这是一个最简单形式的差分方程。 二阶差分当自变量从x变到x+1时，函数y=y(x)一阶差分的差分 Δ(Δy(x))=Δ(y(x+1) - y(x))=Δy(x+1) - Δy(x) =(y(x+2) - y(x+1)) - (y(x+1) - y(x)) =y(x+2) - 2y(x+1) + y(x) 称为二阶差分。 图像的差分方法差分图像就是目标场景在连续时间点图像相减所构成的图像。 差分法是一种用于运动目标检测的可用于克服干扰的行之有效的方法。 两种算法差分法有两种方式： (1)当前图像与固定背景图像的差分； (2)连续两幅图像之间的差分。 第二种算法在很多情况下存在检测物体位置不精确和运算量大的缺点，会影响到定位算法的快速性和准确性。当运动检测开始的时候选择一帧没有运动目标的图像作为差分的背景图像，出现运动目标的时候开始把当前图像和背景图像做差分，当运动目标检测结束时，更新背景图像，当下一个运动目标出现的时候再进行差分。差分的结果可以去除一部分噪声，而且可以去掉与运动目标检测无关的静止背景区域，采用背景图像更新机制，还可以在一定程度上适应背景和光线的变化。在进行差分处理之后，差分图像中只剩下了运动目标和部分噪声，再利用基于投影法的定位算法进行识别和定位。 图像的二阶差分对于一个一维信号，二阶差分可以看作一个点的左边与右边点的相加减去二倍的这个点，二阶差分更适合锐化图像， 是由于二阶差分产生由零分开的一个像素宽的双边缘， 而一阶微分在类似于斜坡过渡时产生较粗的边缘，因为沿斜坡的一阶微分非零。 边界判断1234567891011121314151617 unsigned zbar_scanner_get_edge (const zbar_scanner_t *scn, unsigned offset, int prec) { unsigned edge = scn-&gt;last_edge - offset - (1 &lt;&lt; ZBAR_FIXED) - ROUND; prec = ZBAR_FIXED - prec; if(prec &gt; 0) return(edge &gt;&gt; prec); else if(!prec) return(edge); else return(edge &lt;&lt; -prec);}zbar_color_t zbar_scanner_get_color (const zbar_scanner_t *scn){ return((scn-&gt;y1_sign &lt;= 0) ? ZBAR_SPACE : ZBAR_BAR);} 图像预处理：对运动均值后图像做一阶差分、二阶差分。一阶差分主要用来判定边界两侧像素大小变化。 ZBar边缘判定规则：二阶导数（y1_sign，即最后一个斜坡的坡度)为零的位置是一阶时的最大值或最小值，因此认为是边缘点。 对二阶导数符号发生变化的地方一定存在边缘点，由于进行的是差分运算，需要进行插值找到导数为零的近似位置。另外还需要满足阈值。 三、总结本次博客对ZBar扫描器的内存分配以及图像的边界判断（包括差分的运算和应用）进行了分析，对于scanner.c中关于阈值的计算等内容将在下次博客中分析。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94scanner-c-1/"},{"title":"ZBar源码分析——video.c_2","text":"[TOC] 一、Video模块我们知道，扫描时提供给ZBar的不都是静态的图片，也有可能是动态的视频。例如我们日常生活中调用的微信扫码，所提供的也是视频video，这时便需要Zbar对视频进行分析，动态扫码。 Video模块是ZBar实现对读入视频进行扫描分析的功能模块。核心代码由video.h和video.c组成，video.h包括对一些关键变量的声明和结构体的定义，同时也是其他部件对Video模块的调用接口（头文件），而具体功能代码则是在video.c中实现。 二、代码分析上篇博客对ZBar关于图像和视频之间的转换和处理部分的代码进行了简要分析，这篇博客将继上篇博客往下分析。 ZBar对视频流的创建和销毁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970`1. zbar_video_t *zbar_video_create () 2. { 3. zbar_video_t *vdo = calloc(1, sizeof(zbar_video_t)); 4. int i; 5. if(!vdo) 6. return(NULL); 7. err_init(&amp;vdo-&gt;err, ZBAR_MOD_VIDEO); 8. vdo-&gt;fd = -1; 10. (void)_zbar_mutex_init(&amp;vdo-&gt;qlock); 12. /* pre-allocate images */ 13. vdo-&gt;num_images = ZBAR_VIDEO_IMAGES_MAX; 14. vdo-&gt;images = calloc(ZBAR_VIDEO_IMAGES_MAX, sizeof(zbar_image_t*)); 15. if(!vdo-&gt;images) { 16. zbar_video_destroy(vdo); 17. return(NULL); 18. } 20. for(i = 0; i &lt; ZBAR_VIDEO_IMAGES_MAX; i++) { 21. zbar_image_t *img = vdo-&gt;images[i] = zbar_image_create(); 22. if(!img) { 23. zbar_video_destroy(vdo); 24. return(NULL); 25. } 26. img-&gt;refcnt = 0; 27. img-&gt;cleanup = _zbar_video_recycle_image; 28. img-&gt;srcidx = i; 29. img-&gt;src = vdo; 30. } 32. return(vdo); 33. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 首先为视频对象zbar_video_t *vdo申请内存，大小为zbar_video_所需内存。 若申请成功，则将相机状态置为打开（属性fd决定），若未申请成功，则返回NULL。 打开相机后，则代表着相机资源已被占用，其他视频对象不可使用相机资源。 这一功能由函数_zbar_mutex_init(&amp;vdo-&gt;qlock)来实现，该函数在上篇博客中简单提到过，它实现了视频对象的上锁，即当前状态下不可产生新的视频对象（调用该函数），以免产生资源互斥。 接下来对图像进行预分配。 Zbar采用的处理方式是设定一个图像数量的最大值，然后将视频的图像数量置为该值并申请内存。 接下来根据这个最大值对视频对象进行遍历，对视频中包含的所有扫描得到的图像进行保存和创建，申请内存。并对每一张图像的进行计数、索引，以便调用和分析。 注意到，如果某一张图像出现异常、损坏，ZBar则直接销毁整个视频对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081`1. void zbar_video_destroy (zbar_video_t *vdo) 2. { 3. if(vdo-&gt;intf != VIDEO_INVALID) 4. zbar_video_open(vdo, NULL); 5. if(vdo-&gt;images) { 6. int i; 7. for(i = 0; i &lt; ZBAR_VIDEO_IMAGES_MAX; i++) 8. if(vdo-&gt;images[i]) 9. _zbar_image_free(vdo-&gt;images[i]); 10. free(vdo-&gt;images); 11. } 12. while(vdo-&gt;shadow_image) { 13. zbar_image_t *img = vdo-&gt;shadow_image; 14. vdo-&gt;shadow_image = img-&gt;next; 15. free((void*)img-&gt;data); 16. img-&gt;data = NULL; 17. free(img); 18. } 19. if(vdo-&gt;buf) 20. free(vdo-&gt;buf); 21. if(vdo-&gt;formats) 22. free(vdo-&gt;formats); 23. err_cleanup(&amp;vdo-&gt;err); 24. _zbar_mutex_destroy(&amp;vdo-&gt;qlock); 26. #ifdef HAVE_LIBJPEG 27. if(vdo-&gt;jpeg_img) { 28. zbar_image_destroy(vdo-&gt;jpeg_img); 29. vdo-&gt;jpeg_img = NULL; 30. } 31. if(vdo-&gt;jpeg) { 32. _zbar_jpeg_decomp_destroy(vdo-&gt;jpeg); 33. vdo-&gt;jpeg = NULL; 34. } 35. #endif 36. free(vdo); 37. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 当ZBar需要销毁一个视频对象时，同样不能直接调用free函数释放内存，需要对将该视频对象占用的资源（包括占用的图像数组等）进行销毁后，才能释放视频对象。 这个函数的代码较为浅显，做的工作就是遍历视频对象调用过的图像和阴影部分图像，将其占用内存逐一释放后，最后free(vdo)释放视频对象。 获取相机设备状态12345678910111213141516171819202122231. int zbar_video_get_fd (const zbar_video_t *vdo) 2. { 3. if(vdo-&gt;intf == VIDEO_INVALID) 4. return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__, 5. &quot;video device not opened&quot;)); 6. if(vdo-&gt;intf != VIDEO_V4L2) 7. return(err_capture(vdo, SEV_WARNING, ZBAR_ERR_UNSUPPORTED, __func__, 8. &quot;video driver does not support polling&quot;)); 9. return(vdo-&gt;fd); 10. } 该函数对相机状态的两种异常情况进行了异常处理：视频设备未打开和视频驱动程序不支持轮询。 视频初始化（预处理）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778`1. int zbar_video_init (zbar_video_t *vdo, 2. unsigned long fmt) 3. { 4. #ifdef HAVE_LIBJPEG 5. const zbar_format_def_t *vidfmt; 6. #endif 7. if(vdo-&gt;initialized) 8. /* FIXME re-init different format? */ 9. return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__, 10. &quot;already initialized, re-init unimplemented&quot;)); 12. if(vdo-&gt;init(vdo, fmt)) 13. return(-1); 14. vdo-&gt;format = fmt; 15. if(video_init_images(vdo)) 16. return(-1); 17. #ifdef HAVE_LIBJPEG 18. vidfmt = _zbar_format_lookup(fmt); 19. if(vidfmt &amp;&amp; vidfmt-&gt;group == ZBAR_FMT_JPEG) { 20. zbar_image_t *img; 21. /* prepare for decoding */ 22. if(!vdo-&gt;jpeg) 23. vdo-&gt;jpeg = _zbar_jpeg_decomp_create(); 24. if(vdo-&gt;jpeg_img) 25. zbar_image_destroy(vdo-&gt;jpeg_img); 27. /* create intermediate image for decoder to use*/ 28. img = vdo-&gt;jpeg_img = zbar_image_create(); 29. img-&gt;format = fourcc('Y','8','0','0'); 30. zbar_image_set_size(img, vdo-&gt;width, vdo-&gt;height); 31. img-&gt;datalen = vdo-&gt;width * vdo-&gt;height; 32. } 33. #endif 34. vdo-&gt;initialized = 1; 35. return(0); 36. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 在对视频进行初始化时，ZBar首先判断了该视频是否被初始化过，如果被初始化过，则判定一种异常情况，需要对该视频格式进行重新修正。这一点在我们写代码的过程中容易被忽略，值得学习。 接下来则是对视频进行预处理（创建解码器所需要的视频/图像格式），用于下一步的解码操作。 这里ZBar设定了编码格式为Y800。 对于单色的图像，Y800格式仅包含一个8位Y平面。它的FourCC编码中包含重复的为Y8和灰色对应的编码。这部分将在解码部分的代码中进行分析。 视频流的图像迭代123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102`1. zbar_image_t *zbar_video_next_image (zbar_video_t *vdo) 2. { 3. unsigned frame; 4. zbar_image_t *img; 6. if(video_lock(vdo)) 7. return(NULL); 8. if(!vdo-&gt;active) { 9. video_unlock(vdo); 10. return(NULL); 11. } 13. frame = vdo-&gt;frame++; 14. img = vdo-&gt;dq(vdo); 15. if(img) { 16. img-&gt;seq = frame; 17. if(vdo-&gt;num_images &lt; 2) { 18. /* return a *copy* of the video image and immediately recycle 19. * the driver's buffer to avoid deadlocking the resources 20. */ 21. zbar_image_t *tmp = img; 22. video_lock(vdo); 23. img = vdo-&gt;shadow_image; 24. vdo-&gt;shadow_image = (img) ? img-&gt;next : NULL; 25. video_unlock(vdo); 27. if(!img) { 28. img = zbar_image_create(); 29. assert(img); 30. img-&gt;refcnt = 0; 31. img-&gt;src = vdo; 32. /* recycle the shadow images */ 34. img-&gt;format = vdo-&gt;format; 35. zbar_image_set_size(img, vdo-&gt;width, vdo-&gt;height); 36. img-&gt;datalen = vdo-&gt;datalen; 37. img-&gt;data = malloc(vdo-&gt;datalen); 38. } 39. img-&gt;cleanup = _zbar_video_recycle_shadow; 40. img-&gt;seq = frame; 41. memcpy((void*)img-&gt;data, tmp-&gt;data, img-&gt;datalen); 42. _zbar_video_recycle_image(tmp); 43. } 44. else 45. img-&gt;cleanup = _zbar_video_recycle_image; 46. _zbar_image_refcnt(img, 1); 47. } 48. return(img); 49. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 这部分功能实现的核心在于迭代过程中需要返回视频图像的副本并立即回收驱动程序的缓冲区，以避免资源死锁。 这部分代码与操作系统中的信号量机制类似，对于每一张图像的循环，必须保证缓冲区的有序使用，这就需要对缓冲区进行上锁和解锁。 对于缓冲区的资源，图像之间需要进行递交，在递交过程中，需要借助到tmp暂时图像，在递交结束之后，需要对tmp进行回收，否则会产生相当大的资源浪费。 三、总结本次博客对ZBar扫描器的Video模块的几个关键函数进行了分析。如有不足，敬请指正。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94video-c-2/"},{"title":"ZBar源码分析——多线程部分代码分析","text":"[TOC] 一、ZBar中的多线程在ZBar中，需要进行大量的数据提取和数据获取，若仅仅进行串行处理，往往会出现运行时间过长等问题。因此ZBar中有许许多多的地方都使用了多线程的处理方式，这在前面对各个模块的解析中有所提及。 在引入多线程后，又有许多问题需要注意，例如线程安全的保证、线程同步的实现方式等等。 下面首先对多线程操作时的几个概念以及ZBar中使用多线程的几个地方进行举例说明。 线程：cpu调度的最小单位线程共享进程的资源，多个线程可以共享同一地址空间和其他资源，比如共享全局变量。线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。线程关注的是中央处理器的运行，而不是内存等资源的管理。同一时刻只有一个线程占用cpu，但高速切换给人带来并行的假象。 为什么多线程？ 线程比进程更加轻量级，线程更容易、快捷的创建和销毁。 多CPU系统中，使用线程提高CPU利用率。 耗时的操作使用线程，提高应用程序响应。拥有多个线程允许活动彼此重叠进行，从而会加快应用程序执行速度。 并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。 并行实体共享同一个地址空间和所有可用数据的能力。 何为线程安全？我们经常会听说某个类是线程安全，某个类不是线程安全的。那么究竟什么叫做线程安全呢？ 我们引用《Java Concurrency in Practice》里面的定义： 在不使用额外同步的情况下，多个线程访问一个对象时，不论线程之间如何交替执行或者在调用方进行任何其它的协调操作，调用这个对象的行为都能得到正确的结果，那么这个对象是线程安全的。 也可以这么理解： 多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性，也就是说我们不用考虑同步的问题。 锁机制通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。 所谓的锁，可以理解为内存中的一个整型数，拥有两种状态：空闲状态和上锁状态。加锁时，判断锁是否空闲，如果空闲，修改为上锁状态，返回成功。如果已经上锁，则返回失败。解锁时，则把锁状态修改为空闲状态。 二、ZBar中使用多线程的代码示例Window线程的上锁与解锁在渲染窗口时，必须保证渲染函数window.draw是线程安全的。ZBar对于线程安全方面的处理都是采用互斥锁和信号量实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253`1. static inline int window_lock (zbar_window_t *w) 2. { 3. int rc = 0; 4. if((rc = _zbar_mutex_lock(&amp;w-&gt;imglock))) { 5. err_capture(w, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 6. &quot;unable to acquire lock&quot;); 7. w-&gt;err.errnum = rc; 8. return(-1); 9. } 10. return(0); 11. } 13. static inline int window_unlock (zbar_window_t *w) 14. { 15. int rc = 0; 16. if((rc = _zbar_mutex_unlock(&amp;w-&gt;imglock))) { 17. err_capture(w, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 18. &quot;unable to release lock&quot;); 19. w-&gt;err.errnum = rc; 20. return(-1); 21. } 22. return(0); 23. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 当有渲染窗口的线程获得了互斥锁，其他线程则必须等待，直到其释放锁。 Vedio视频流的上锁与解锁在对视频流进行锁定和解锁时，都必须保证线程安全，即不允许出现互斥情况，即有一个视频流以上同时进入临界区。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384`1. /* video.next_image and video.recycle_image have to be thread safe 2. * wrt/other apis 3. */ 4. static inline int video_lock (zbar_video_t *vdo) 5. { 6. int rc = 0; 7. if((rc = _zbar_mutex_lock(&amp;vdo-&gt;qlock))) { 8. err_capture(vdo, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 9. &quot;unable to acquire lock&quot;); 10. vdo-&gt;err.errnum = rc; 11. return(-1); 12. } 13. return(0); 14. } 16. static inline int video_unlock (zbar_video_t *vdo) 17. { 18. int rc = 0; 19. if((rc = _zbar_mutex_unlock(&amp;vdo-&gt;qlock))) { 20. err_capture(vdo, SEV_FATAL, ZBAR_ERR_LOCKING, __func__, 21. &quot;unable to release lock&quot;); 22. vdo-&gt;err.errnum = rc; 23. return(-1); 24. } 25. return(0); 26. } 28. static inline int video_nq_image (zbar_video_t *vdo, 29. zbar_image_t *img) 30. { 31. /* maintains queued buffers in order */ 32. img-&gt;next = NULL; 33. if(vdo-&gt;nq_image) 34. vdo-&gt;nq_image-&gt;next = img; 35. vdo-&gt;nq_image = img; 36. if(!vdo-&gt;dq_image) 37. vdo-&gt;dq_image = img; 38. return(video_unlock(vdo)); 39. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 可以看到，ZBar实现线程安全的方式是使用互斥锁，下面对ZBar互斥锁的实现进行分析。 三、源码分析从上面的举例中可以看到，ZBar使用互斥锁时使用的核心函数如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788`1. typedef pthread_mutex_t zbar_mutex_t; 3. static inline int _zbar_mutex_init (zbar_mutex_t *lock) 4. { 5. # ifdef DEBUG_LOCKS 6. pthread_mutexattr_t attr; 7. pthread_mutexattr_init(&amp;attr); 8. pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK); 9. int rc = pthread_mutex_init(lock, &amp;attr); 10. pthread_mutexattr_destroy(&amp;attr); 11. return(rc); 12. # else 13. return(pthread_mutex_init(lock, NULL)); 14. # endif 15. } 17. static inline void _zbar_mutex_destroy (zbar_mutex_t *lock) 18. { 19. pthread_mutex_destroy(lock); 20. } 22. static inline int _zbar_mutex_lock (zbar_mutex_t *lock) 23. { 24. int rc = pthread_mutex_lock(lock); 25. # ifdef DEBUG_LOCKS 26. assert(!rc); 27. # endif 28. /* FIXME save system code */ 29. /*rc = err_capture(proc, SEV_ERROR, ZBAR_ERR_LOCKING, __func__, 30. &quot;unable to lock processor&quot;);*/ 31. return(rc); 32. } 34. static inline int _zbar_mutex_unlock (zbar_mutex_t *lock) 35. { 36. int rc = pthread_mutex_unlock(lock); 37. # ifdef DEBUG_LOCKS 38. assert(!rc); 39. # endif 40. /* FIXME save system code */ 41. return(rc); 42. } `![](https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png) 使用函数解析——pthread_mutex_init12345671. int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr); 3. pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 函数作用： 该函数用于C函数的多线程编程中，互斥锁的初始化。 pthread_mutex_init() 函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为空，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。 pthread_mutexattr_init() 函数成功完成之后会返回零，其他任何返回值都表示出现了错误。 函数成功执行后，互斥锁被初始化为未锁住态。 互斥锁pthread_mutex_t的使用： 1. 互斥锁创建 有两种方法创建互斥锁，静态方式和动态方式，ZBar中采用的是后者。 静态初始化互斥锁方法如下： 1pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIZER; 动态方式是采用pthread_mutex_init()函数来初始化互斥锁，API定义如下： 1int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr) 其中mutexattr用于指定互斥锁属性（见下），如果为NULL则使用缺省属性。 pthread_mutex_destroy ()用于注销一个互斥锁，API定义如下： 使用函数解析——pthread_mutex_destroy12345678910111. static inline void _zbar_mutex_destroy (zbar_mutex_t *lock) 2. { 3. pthread_mutex_destroy(lock); 4. } 销毁一个互斥锁即意味着释放它所占用的资源，且要求锁当前处于开放状态。 互斥锁属性互斥锁的属性在创建锁的时候指定，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。当前有四个值可供选择： * PTHREAD_MUTEX_TIMED_NP 缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。 * PTHREAD_MUTEX_RECURSIVE_NP 嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。 * PTHREAD_MUTEX_ERRORCHECK_NP 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。（这正是ZBar使用的互斥锁类型） 1pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_ERRORCHECK); * PTHREAD_MUTEX_ADAPTIVE_NP 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 锁操作锁操作主要包括： 12345678910111. int pthread_mutex_lock(pthread_mutex_t *mutex) 3. int pthread_mutex_unlock(pthread_mutex_t *mutex) 5. int pthread_mutex_trylock(pthread_mutex_t *mutex) pthread_mutex_trylock()语义与pthread_mutex_lock()类似，不同的是在锁已经被占据时返回EBUSY而不是挂起等待。 不论哪种类型的锁，都不可能被两个不同的线程同时得到，而必须等待解锁。 对于普通锁和适应锁类型，解锁者可以是同进程内任何线程； 而检错锁则必须由加锁者解锁才有效，否则返回EPERM； 对于嵌套锁，文档和实现要求必须由加锁者解锁，但实验结果表明并没有这种限制，这个不同目前还没有得到解释。 在同一进程中的线程，如果加锁后没有解锁，则任何其他线程都无法再获得锁。 三、总结本次代码分析对ZBar中线程安全的实现方式以及使用函数进行了详细分析，这也是对之前代码分析中一些缺漏的补充说明。","link":"/2021/03/11/ZBar%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"ZBar项目简介及安装配置","text":"ZBar项目简介及安装配置[TOC] 前言在我们的日常生活中，处处可见条形码和二维码。 在以前，我们去逛书店时，或者你现在随手拿起你身边的一本书，你肯定能看到书本的封页后面印有一排黑色线条组成的标签，也就是条形码；你去你们学校图书馆的自助机上借书还书时识别的也是条形码；哦，对了，你还记得每次大型考试答题卡上都会贴上监考老师分发给你的那个标签吗？还是条形码；甚至现在你随随便便逛个超市或便利店，收银员或者自助机也都是通过扫商品条形码给你计价的。条形码在我们的日常生活中真的是随处可见。 到了后来，2016年之后，二维码也渐渐开始普及起来，现在二维码几乎成了我们日常生活的一部分：新朋友微信加个好友；上下班搭乘公交地铁；平时买东西付款；和别人收付款的当面交易；各个大小公司或者商场甚至地摊搞活动**的时候也告诉你扫码有优惠。 现在只要你出门，或者你不出门，你只要用手机，你是个网民，你就很难不接触到各种条形码与二维码。 那么这些个条形码识别和二维码识别是怎么完成的呢？ 这就涉及到了本文要介绍的ZBar项目。 一、ZBar是什么？ZBar条形码阅读器（ZBar bar code reader）是一个用于读取条形码的开源软件套件。 它支持识别不同来源的文件类型，如视频流、图像文件和原始数据强度传感器。ZBar的算法可识别大部分种类的一维码（条形码），比如I25，CODE39，CODE128，二维码等等。 ZBar项目包括C、C++、Python和Perl多种语言共同实现以及用于Qt、GTK和PyGTK的GUI小部件。 1.软件安装1.1 ZBar安装ZBar bar code reader - Downloadhttp://zbar.sourceforge.net/download.html 下载后根据流程安装，需要注意此处勾选 Development Headers and Libraries 最后将项目安装在常用文件夹下（此处我选择放在C:\\Program Files (x86)下） 由于ZBar的默认环境为win32，若在64位机器上使用Zbar，还需要一些库文件 从github下载64位ZBar的源码包 ZbarWin64下载https://github.com/dani4/ZBarWin64 解压后将 ZBarWin64-master\\lib 文件夹下 libzbar64-0.lib 文件复制到ZBar安装路径下的 lib 文件夹 将 ZBarWin64-master\\lib 文件夹下 libzbar64-0.dll 文件复制到ZBar安装路径下的 bin 文件夹 将ZBarWin64-master\\zbar\\libiconv\\dll_x64文件夹下 libiconv.dll 复制到ZBar安装路径下的bin 文件夹这部分配置教程来自 原文链接：https://blog.csdn.net/weixin_40689871/article/details/109462028 1.2 OpenCV安装OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在**Linux、Windows、Android和Mac OS**操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。 这里采用OpenCV库辅助进行二维码的采集和代码的测试。 OpenCV下载https://opencv.org/releases/根据流程解压、安装后，最后将项目放在常用文件夹下（此处我选择放在C:\\Program Files (x86)下） 2.环境配置2.1 系统环境配置打开 高级系统设置–环境变量–系统变量–Path 把OpenCV和Zbar安装包里的这两个文件目录放在系统变量的路径下即可 2.2 Visual Studio环境配置打开 视图—其他窗口—属性管理器 单击右侧属性管理器，右键debug|x64（其他也可，配置项不同），添加一个新项目属性表，接下来对这个属性表进行配置。 双击刚刚新建的项目的属性表的属性页界面： (1)VC++目录—包含目录 添加opencv的include路径和zbar的include路径（按照安装路径） …\\opencv\\build\\include …\\opencv\\build\\include\\opencv …\\opencv\\build\\include\\opencv2 …\\ZBar\\include (2) VC++目录—库目录 添加opencv和zbar的lib路径 …\\opencv\\build\\x64\\vc15\\lib …\\ZBar\\lib (3) 链接器—输入—附加依赖项 添加opencv和zbar的依赖 opencv_world343d.lib（根据安装的版本 在…\\opencv\\build\\x64\\vc15\\lib中查看） libzbar-0.lib libzbar64-0.lib 3.代码测试配置环境完成后，重启电脑。 测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;opencv2/imgproc.hpp&gt; // Gaussian Blur#include &lt;opencv2/core.hpp&gt;#include &lt;opencv2/videoio.hpp&gt;#include &lt;opencv2/highgui.hpp&gt; // OpenCV window I/O#include &lt;opencv2/features2d.hpp&gt;#include &lt;opencv2/objdetect.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;iostream&gt;#include &lt;zbar.h&gt;using namespace cv;using namespace std;using namespace zbar;int main(){ ImageScanner scanner; scanner.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1); //调用系统摄像头，若只有一个摄像头则参数为0 VideoCapture cap(1); Mat mFrame; while (1) { cap &gt;&gt; mFrame; Mat image = mFrame; imshow(&quot;camera&quot;, mFrame); Mat imageGray; cvtColor(image, imageGray, COLOR_BGR2GRAY); int width = imageGray.cols; int height = imageGray.rows; uchar* raw = (uchar*)imageGray.data; // 在Zbar中进行扫描时候， //需要将OpenCV中的Mat类型转换为（uchar *）类型，raw中存放的是图像的地址； //对应的图像需要转成Zbar中对应的图像zbar::Image Image imageZbar(width, height, &quot;Y800&quot;, raw, width * height); //Y800=GREY 是GRAY灰度图像 scanner.scan(imageZbar); Image::SymbolIterator symbol = imageZbar.symbol_begin(); for (; symbol != imageZbar.symbol_end(); ++symbol) { cout &lt;&lt; &quot;类型：&quot; &lt;&lt; endl &lt;&lt; symbol-&gt;get_type_name() &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;条码：&quot; &lt;&lt; endl &lt;&lt; symbol-&gt;get_data() &lt;&lt; endl &lt;&lt; endl; } waitKey(5); //waitKey()函数的功能是不断刷新图像，频率为delay，单位是ms } waitKey(); return 0;} 使用OpenCV打开电脑摄像头并对视频的每一帧进行采集后，调用Zbar对二维码（或其他码）进行分析 运行结果： 4.遇到问题测试程序虽然并不复杂，但第一次接触，还是遇到了问题。 121. CvCapture* capture = cvCreateFileCapture(0);2. //类似语句调用OpenCV打开摄像头在调试时会报错 以上代码在编写时没有语法报错，一旦调试就会报错。 12\\[ WARN:0\\] cvCreateFileCaptureWithPreference: backend FFMPEG doesn't support legacy API anymore.\\[ WARN:0\\] cvCreateFileCaptureWithPreference: backend MSMF doesn't support legacy API anymore. 查找资料发现是因为高版本的OpenCV已经不支持这样的C语言风格的代码，而是建议用上面C++面向对象风格编写代码。 三、Linux下Zbar的安装及使用(Ubuntu)1.环境搭建 安装依赖项 安装zbar工具 - zbarimg等 添加依赖 下载解压源码 进入zbar文件夹，创建安装输出文件夹 12345678910111213141516//安装依赖项sudo apt-get install libqt4-dev libv4l-dev python-gtk2-dev imagemagick libmagickwand-dev //安装zbar工具 - zbarimg等sudo apt-get install zbar-tools //添加依赖sudo ln -s /usr/include/libv4l1-videodev.h /usr/include/linux/videodev.h //下载解压源码wget http://downloads.sourceforge.net/project/zbar/zbar/0.10/zbar-0.10.tar.gztar -vxzf zbar-0.10.tar.gz //进入zbar文件夹，创建安装输出文件夹cd zbar-0.10&amp;&amp;mkdir output 2.编译安装 从源码进行安装需要预先配置相关内容 1234//配置选项 --prefix：指定install路径 CFLAGS ：指定编译时的自定义头文件路径 (可选)./configure --prefix=$PWD/output/ --enable-shared --disable-video --without-python --without-gtk --without-qt --without-imagemagick CFLAGS=&quot;&quot;//编译和安装 -- 文件会输出到outputmake&amp;&amp;make install 3.测试验证 利用工具生成二维码 利用编译的zbarimg 进行扫码测试 123456#下载工具 qrencodesudo apt-get install qrencode#生成二维码qrencode -o test.png -s 18 ‘http://www.baidu.com’#测试二维码./zbarimg test.png 四、嵌入式交叉编译Zbar(RISC-V) 搭建交叉编译环境 riscv64-unknown-linux-gnu-gcc的相关工具预先配置 同Linux源码进行安装 利用pkg-config 编译 123456789101112#解压tar -xvf zbar-0.10.tar.gz#配置./configure CC=gcc/linux-x86/riscv/toolchain-thead-glibc/riscv64-glibc-gcc-thead_20200702/bin/riscv64-unknown-linux-gnu-gcc --host=riscv64-unknown-linux-gnu --prefix=$PWD/output/ --without-gtk --without-qt --without-pythonexport -p CFLAGS=&quot;&quot;./configure --host=x86_64-linux-gnu --prefix=$PWD/output/ --without-gtk --without-qt --without-python --disable-video#编译安装make -j20&amp;&amp; make instll#pkg-configexport PKG_CONFIG_PATH=$PKG_CONFIG_PATH:project/github/application/zbar-0.10/output/libpkg-config --libs --cflags zbar* 总结 ZBar项目涉及知识十分丰富且复杂，本次各种环境下对ZBar进行了安装、配置以及简单的测试和使用，后续将开展详细的代码分析工作。","link":"/2021/03/09/ZBar%E9%A1%B9%E7%9B%AE%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"},{"title":"学习书籍推荐","text":"学习书籍推荐 1. 0x1-软件开发1.1. 软件工程 《人月神话》 《人件》 《硝烟中的Scrum和XP》 《Scrum敏捷软件开发》 《敏捷软件开发》 1.2. 软件需求 《软件需求》- S4， 《掌握需求过程》- S4， 1.3. 软件设计 《编程的原则：改善代码质量的101个方法》 《架构整洁之道》 《软件架构建模和仿真》 《设计模式》- S2， 《Head First 设计模式》- S2， 《设计原本》- S3， 《恰如其分的软件架构》- S4， 《UML参考手册》- S4， 《UML用户指南》- S3， 《领域驱动设计》- S4， 《编写有效用例》 《面向模式的软件架构》 1.4. 软件编码 《C程序设计语言》- S0， 《C专家编程》- S1， 《C陷阱与缺陷》- S1， 《代码大全》- S1， 《代码整洁之道》- S1， 《算法》- S2， 《编程珠玑》- S2， 《修改代码的艺术》- S2， 《重构》- S2， 《计算机程序的构造和解释》 《数据结构与算法分析 : C语言描述》 1.5. 软件测试 《软件测试的艺术》- S3， 《完美软件：对软件测试的各种幻想》- S4， 《Google 软件测试之道》- S4， 2. 0x2-计算机基础2.1. 操作系统 《Linux内核设计与实现》- S1， 《Linux/UNIX系统编程手册》- S1， 《现代操作系统》- S2， 《Unix环境高级编程》- S2， 《UNIX操作系统设计》- S2， 《Linux Shell脚本攻略》- S2， 《Linux 系统编程》- S2， 《UNIX网络编程》- S2， 《Linux设备驱动》- S3， 《深入Linux内核架构》- S5， 2.2. 计算机网络 《TCP/IP详解 卷1：协议》- S0， 《计算机网络》- S1， 《密码编码学与网络安全》 《用TCP/IP进行网际互联》 2.3. 体系结构 《深入理解计算机系统》- S5， 《计算机体系结构》- S5， 《ARM体系结构参考手册》- S5， 3. 0x3-软技能 《程序开发心理学》- 5星 《高效能程序员的修炼》- 5星 《软技能-代码之外的生存指南》- 5星 《程序员的呐喊》- 4星 《程序员的职业素养》 《番茄工作法图解》 《比特素养》 《搞定:压力工作的艺术》 《原则》- 5星 《见识》- 4星 《影响力》 《非暴力沟通》 《清醒思考的策略 : 做正确的事，把事做正确》 《批判性思维》","link":"/2022/01/18/%E5%AD%A6%E4%B9%A0%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"},{"title":"嵌入式编程问题总结","text":"嵌入式编程问题总结 嵌入式编程问题总结前言在嵌入式编程中，我们经常会遇到许多问题，应该及时总结和思考，尽量在编写代码的时候注意避免。因为很多问题可能造成难以复现，定位的BUG,对项目和后期维护都会花费很大的精力。 代码运算符优先级同一行代码(将过长的代码分成不同物理行也算作一行)中，如果有多个运算符，建议按照预想的运算符执行顺序，将运算符加()。尤其是!、&amp;、^、|、&amp;&amp;、||、&lt;&lt;、&gt;&gt;、+、-，这些运算符的优先级容易搞混。比如之前优化代码的时候就发现 a = b &lt;&lt; 8 + c这种代码，但实际上 + 比 &lt;&lt; 优先级高，结果将是错误的。从上下文分析，实际代码应该是 a = (b &lt;&lt; 8) + c。 ++、–运算符如果不是必须的，不要作为宏的参数的一部分。比如ip_ntohl宏，它展开后将是((((xx) &lt;&lt; 24) &amp; 0xff000000U) | (((xx) &lt;&lt; 8) &amp; 0x00ff0000U) | (((xx) &gt;&gt; 8) &amp; 0x0000ff00U) | (((xx) &gt;&gt; 24) &amp; 0x000000ffU))，传入的参数会出现4次，因此如果传入了++、–运算符，那么将进行4次++、–运算，结果可能就不是预期的值。 函数逻辑if、else、for、while、do..while建议将其配套的代码段，加上{}，并且单独放一行。 即使只有一行代码或者是空，也要加上{}，这样即增加了可读性，同时在后续更改代码的时候也不容易出错。比如之前的代码，后续修改时非常容易出错 123456 if (write); //cli_out (cli, &quot;!\\n&quot;); spt_printf(SPT_QUIT_STR);或者 if(iErr == OK) //script_save_cfg(); return iErr; 函数返回值 函数的返回类型和实际代码要对应。 目前我们项目中代码有不少函数定义了返回值，但实际代码中不是每种情况都返回了值；甚至有时候没有任何return。有些函数的返回值，后续是在使用的，这样在用的地方就是个随机值。比如下面的函数(SVN中已经增加了else返回NULL) 123456struct sh_author_attr *author_attr_record_get( int vty_num ){ login_current_user_t *u = cli_user_get_current_user(); if(u) { return u-&gt;author_attr_record; }} 另外一个情况是，函数定义的是void类型，但函数中有return (value)这种情况。LLVM会对这个报错，但GCC/diab不会。 局部变量 函数中的局部变量，在使用之前必须要被赋值。 如果不赋值，或者赋值语句在一些复杂的条件下，可能就会造成使用的时候，是一个随机值。这一项会有编译器警告，修改代码时注意看警告。 数据类型 数据类型不要轻易混用 在我们目前使用的64位系统上，long和ptr已经变成64位长度，而int仍然是32位。在升级位64位系统时，这类混用，绝大部分已被发现和排除了。后续新增代码也要注意不要混用 结构体对齐 此问题同样是在系统升级为64位时出现最多。以前代码中，由于是32位系统，int/long/ptr都是32位长，因此在结构体中可以任意排列，最大对齐宽度是32位；但64位系统中，long/ptr变成64位，最大对齐宽度随之变化。因此，结构体中，必须要优先考虑long/ptr的位置 立即数 获取和使用长度的时候，尽量避免用立即数，而应使用sizeof或者宏。 此问题绝大部分情况下和结构体有关，如上面结构体对齐中所述。以前代码中有很多操作结构体相关的内存时，使用了立即数来指定结构体大小，造成在升级到64位系统时，出现了很多难以定位和查找的问题。 指针与函数 C库函数中，对于内存操作的函数的使用，对于长度一定要确保在预期范围内。接收指针参数/返回指针的库函数，都要检查相应指针是否为空。 以strncpy/snprintf等函数替代strcpy/sprintf，保证操作字符串时长度受控。并且对于查找类的字符串库函数，要检查其返回值是否为空。同时在不同的操作系统上，memcpy/strlen等函数，传入NULL会直接导致任务STOP。 函数的参数中，如果有传入指针的情况，一定要传入对应类型的指针。除非完全明确传入不同类型的指针是正确的。 如下代码会导致传入的int类型参数a的下一个相邻的变量被修改。 123456789101112131415161718char *get_num(char *a, unsigned long *n){ char *p=a; if(!isdigit(*p)) return NULL; *n = 0; while ((*p) &amp;&amp; (isdigit(*p)) &amp;&amp; (*p!='\\0')) { *n *= 10; *n += (*p++ - '0'); } return p;}int main(int argc, char **argv){ int a=1,b=2; get_num (“55555555555”, &amp;a); return 0;} 函数在调用的那一行之前，一定要有函数原型出现。 规范的做法是将函数原型声明放在对应的头文件中，在其它文件中包含该头文件即可，避免到处都是出现函数原型，而如果后面要改函数原型时容易改漏。 函数未声明目前出现了3种问题。 1). 返回指针的函数在64位系统上，指针将被截断，出现非法指针。进而造成任务stop. 2). 函数原型和实际使用时，参数个数、类型不匹配，传递了错误的参数。在SVN-17204版本更改就是这类问题。 3). 在64位的LLVM编译器上，将会导致编译错误。其情形是，在同一个源文件中，在100行调用函数foo，但在200行出现了函数体，而在100行之前没有foo的声明。这种情形，LLVM会报一个foo类型不匹配的错误。解决办法就是在100行之前，声明一下foo。 所以函数使用前声明，编译器都可以帮我们检查一些问题出来，并且在64位上也是迫切需要的。 操作系统SMP多核系统中，共享资源，必须要做好保护和同步。 多核处理器，就是一个芯片封装下，有多个CPU核心。它们可以真正意义上实现同一时刻，多个任务在运行，类似于FPGA的并行执行。因此我们一定要改变过去在单核系统上的观念。在写代码时，尤其是在涉及到和其它任务有交互时，不能再依赖于任务间的优先级来实现共享资源的互斥保护。 凡是要与其它任务共享的资源，增/删/改/查，都要做好保护。增/删/改，都要当作原子操作，不能被新动作打断；并且在进行这三种操作期间，不能查询，否则可能得到脏数据。 在某个BUG的改动中，就是某个任务在共享的cmd_hotswap_transit_t结构体AVL树中增加节点时，正好有主备同步的主用任务hotswap_s查询到这个节点。由于增加动作尚未完成（只创建了节点的key，该节点的内容尚未填充），而主用任务就正好查找到该节点并开始使用，所以使用到的节点内容都是无效的，从而造成了死机。 后记无论是小项目还是大项目，对于整个项目或者程序而言，编程的质量把控是必须的，嵌入式C也只能不断总结，不断避免BUG,而不是发现BUG再去解决它。从系统层面来看，越庞大的系统越容易出现稀奇古怪的问题，对于工程师来说，不仅只是满足功能，而更多我们需要考虑系统和架构上去规避。","link":"/2021/07/18/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"嵌入式知识图谱","text":"嵌入式知识图谱​ 嵌入式做为一个软硬件结合的技术，它的知识涵盖面是相当多的，作为一个嵌入式从业者而言，需要的是有一个全局的认识，以及完整的学习路线。 项目描述​ 作为一个简单的项目需要有需求，开发，测试，运维。如果按照完整的IPD流程来完成一个项目的话，这需要大量的人力和物力，一般只有大一点的公司才会做。 注：集成产品开发（Integrated Product Development，IPD）是一套先进的、成熟的研发管理思想、模式和方法。 简单的项目开发活动有以下内容，这里作为开篇文档不会详细对项目进行描述。 一个开源项目-SONIC​ 国内互联网企业开发的白盒设备OS系统基本都基于SONiC开发（Software for Open Networking in the Cloud）。SONiC由微软开发并于2016年开放计算组织OCP（Open Compute Project）峰会上发布。SONiC所有功能组件模块均已开源，供OCP成员企业免费使用。 嵌入式核心技能​ 这里先放一张网上的开发技能图，可能大家觉得很多知识点，但是这个都是逐步学习的过程的。不是一蹴而就的，B站大佬稚晖君十年前也是一步步问着学习过来的。 ​ 我比较推荐仲一大佬的学习路线图《嵌入式与Linux那些事》公众号。但是这里我想说的是，51和STM32工资相对较低，入门学习后除了物联网行业可以冲一下，其他的都上Linux比较好。 嵌入式Linux​ 我其实早期的学习是通过做嵌入式Linux系统开发的来逐步成长的。它也涵盖了一个嵌入式项目的方方面面，如图所示。从硬件到软件，最后到一个产品，形成了一个完整的项目。后续的文章中，我们也会逐步来体现这些内容。 嵌入式行业需要什么样的技术人才？嵌入式行业需要什么样的技术人才？仔细观察各种招聘的岗位要求吧，无非是两方面。 1）通用要求 ​ 比如什么学历，多少年工作经验，有创新精神，抗压能力强，吃苦耐劳，善于沟通，态度认真等等等等… 2）专业要求 ​ 这个可真的多了去了，但无非就是各种精通。什么精通控制理论，精通电路设计，精通各种硬件驱动开发，精通linux内核，精通DSP，精通ARM，精通嵌入式数据库，精通多线程编程，精通各种网络协议，精通各种总线协议，精通塞班/安卓/IOS平台应用开发。精通汇编、编译器、二进制工具，精通各种媒体封装格式、编解码，精通通信技术，精通硬件原理图，精通PCB设计，精通计算机结构，精通bootloader，精通……感觉只要是行业内的就要精通。 ​ 看完这些，尤其是专业要求，精通一门就得好久，头大了吧？那么，我们来就分析一下上面的要求吧。各个公司就通用要求像是互相复制粘贴的一样，比如学历，个人认为学历明显更重要；比如经验，是有n年的经验，还有n年前的经验用了n年；还有个人秉性，我都不知道各个公司怎么在员工入职前考察。专业要求呢，其实精通其中几样就挺了不起了，很多技能一看就让人头晕，了解了嵌入式开发的结构可能就好理解些了。 从技术实现上讲，嵌入式的产品分为两大类：一类简单的，没有操作系统支持的;一类复杂的，有操作系统的。 就目前发展方向看，后一种是趋势。前一种从程序实现上可以分为3层：硬件层、驱动层、应用层；后一种可以分为4层：硬件层、驱动层、系统层、应用层。 所以，嵌入式的开发大致需要这么从下到上四类工程师：嵌入式硬件开发、嵌入式驱动开发、嵌入式系统开发、嵌入式软件开发。 嵌入式硬件开发​ 这是硬件工程师来做，一般出身为自动化，电子，通信等专业，他们要求熟悉电路等知识，非常熟悉各种常用元器件，掌握模拟电路和数字电路设计的开发能力，熟悉硬件开发模式和设计模式，熟悉各种芯片及外围设备，熟悉8位16位32位处理器嵌入式硬件平台开发。有的要求有FPGA的开发经验，精通常用的硬件设计工具：一般要有4~8层高速PCB设计经验。 Protel PADS(PowerPCB) Cadence OrCad 嵌入式驱动开发​ 这个可以硬件工程师来做，也可以软件工程师来做，主要还是取决于设备。目前驱动开发，除非是简单的设备驱动，实际上很多时候都是移植，所以更多的是需要掌握目标平台的硬件和系统特性。所以至少得掌握一些操作系统、系统结构、计算机组成原理、数据结构相关知识。熟悉嵌入式ARM/MIPS/PowerPC架构。 ​ 具有单片机、某种或多种32位嵌入式处理器的移植开发能力，熟悉bootloader过程，具有扎实的硬件知识，理解硬件原理图，能独立完成相关硬件驱动调试，能够根据芯片手册编写软件驱动程序。如果涉及到网络设备，或许还要掌握很多高层的网络协议的原理。个人感觉这一块虽然大部分不是很难，但却是极为重要的。当然如果要在这一层次提供对上层的多线程支持，某些驱动也是很难写的。 嵌入式系统开发​ 这块，熟悉操作系统的原理是必不可少的，比如内存管理，比如线程调度，比如文件系统等等。还要精通处理器体系结构、指令集、寻址方式、调试、汇编和混合编程等方面的内容;熟悉操作系统启动流程。对于linux，要熟悉Linux配置文件的修改，掌握内核裁减、内核移植、交叉编译、内核调试、启动程序Bootloader编写、根文件系统制作和集成部署Linux系统等整个流程。这一块要是真写起来，困难程度那是相当恐怖的，好在大多都是移植，很少听说有公司要去开发个操作系统的，没Google的实力啊。 嵌入式软件开发​ 这个嘛，没有操作系统的话，程序一般不会特别复杂，如果有操作系统的支持，又和一般的软件开发很接近，所以尽可以看作是搞桌面开发。这个要求就是熟悉系统的API，精通C语言的高级编程知识，包括函数与程序结构、指针、数组、常用算法、库函数的使用等知识、数据结构的基础内容;掌握面向对象编程的基本思想，以及C++语言的基础内容。精通嵌入式Linux下的程序设计，精通嵌入式Linux开发环境，包括系统编程、文件I/O、多进程和多线程、网络编程、GUI图形界面编程、数据库。熟悉常用的图形库的编程，如GTK、miniGUI、fltk、nano-x、QT等，掌握各种应用层的网络协议使用，以及各种音视频技术等。 通用技能另外还有些以上四类都用得着的技能。 1）基础技能：搞嵌入式开发，还有一些必不可少的基础技能 开发平台的熟悉。目前的嵌入式开发大多数是在linux或者类linux下的环境下进行的，那么linux的使用应该熟悉吧，shell脚本得会写吧，配置文件得会改吧，GCC GDB得会用吧，Make工具得会吧? 比如项目管理工具的使用，都什么年代了，不会用CVS，也不会用SVN？请问，你还活在软件时代的原始社会么? 数据结构和算法。搞软件开发，不懂数据结构，不会算法优化，不会衡量复杂度，太不靠谱了吧？ 当然，这个也不是要求啥算法都要会，啥数据结构都记得住，最起码得知道有那么种东西，有什么作用，这样用到的时候好歹也能查啊。 编程语言。关于JAVA，我知道现在JAVA的异军突起，很是震动了编程语言界，但是在嵌入式开发下，不会C或者C++语言，实在说不过去。 当然现在很多手机应用完全用java写的，如果你只想搞嵌入式的上层软件开发又不想深入下去，只用JAVA也未尝不可。 关于汇编，嗯，这个可能挺难，毕竟跟具体的硬件架构(主要是CPU)有关，但是真的很有意思，而且在某些时候，它是不可替代的。 2）特殊技能：对于嵌入式开发的某些部分必不可少，但对于有些(比如应用开发)可能没有多大用处 数字电路。这个主要是了解一些基本的电路知识，如门电路、逻辑电路、存储器、寄存器，为了更好的理解嵌入式芯片、存储器、外围设备等硬件的设计，但往往在软件开发中未必能用的到。因为大部分硬件都提供了很完整的软件接口。 操作系统。这个说的是平台上选用的操作系统。嵌入式产品操作系统实在是太多了。 但操作系统的内部设计原理都是殊途同归。 首先，要去学习的是操作系统原理，要去了解进程通信、内存管理、文件系统等等几个重要的部分，因为这些在软件开发尤其是内核驱动开发时会用到。 接下来，可以去熟悉至少一种主流的操作系统，Linux是一个很好的选择，去了解它的内核架构，设备驱动架构，如何去编译、裁剪、编写应用程序，以及如何使用在具体的嵌入式产品上。 计算机的组成/微机原理。主要是为了了解微型计算机的硬件工作原理，明白CPU、总线、I/O、存储器等一些关键结构是怎么工作的，虽然是很枯燥的知识，但是对熟悉外围设备硬件工作方式，及操作系统，软件架构的设计及优化相当关键。 3）扩展的能力：这些可能是要用到的 通信协议。对于非应用层的通信协议，我实在不知道是不是该把它放入操作系统的范畴，因为很多操作系统是没有网络部分的，但是在很多方面它又是由操作系统提供。 当然这些下层通信协议，貌似不太用关心，因为太多的开源协议栈了。应用层的网络协议可能就要关心了，比如http、ftp、rtsp、rtmp、mms等等。 音视频处理。比如文件封装、音视频的编解码、各种音视频的标准，还有流媒体什么的。Ffmpeg是一个很好的东西，建议学习一下。 信息安全。嗯，这一块貌似现在越来越受到重视了。 数据库。唉，嵌入式设备能力越来越强啊！再搞搞，我看也不用交叉编译了。 ​ 有时和同事讨论起现在的行业需求，说到各个公司总是招不到人，程序员又总说找不到工作，自己就有很多感想，是公司要求高，还是程序员要求高？有时候看到一些招聘的职位要求，总是打击到自己的信心，一条一条数下来，好像自己能做到的还真没多少，只好让自己再努力些再努力些。当然有时也会觉得某些招聘不靠谱，看那一条条的要求，个人感觉要是全做到，普通人怎么也得努力个十年八年的，这样的大牛们，估计看不上给出的那薪资吧。对于程序员来讲，做技术真的是很累很难的一件事情。网上搜一下，遍地的抱怨贴、情感贴，都充分反映了这个职业对身体和情感的考验。如果你不畏艰难，想把技术做下去，那么努力吧，也许某天你会随便拿起一份招聘启事，鄙视一眼：“靠!就这点要求，老子去都掉价!”，那么你就是真正的大牛了！ 现有状况分析不少新人来到我们研发已近十几年。这十几年里，同一批人员，有的已经很快适应了环境，经过自己的努力和付出，能为研发工作独挡一面，成为某一方面的小专家； 有的尽管前期不太适应，但是通过指导和修正，业已慢慢进入了工作状态，相信经过一段时间，会逐步担当起某一方面的研发工作。同一时期进来工作，为什么他们现在的能力和状态会产生如此大的差异呢？通过的相处和分析，我发现凡是进步快的同志有如下特点： 勤奋，为了解决一个技术问题经常会主动留下来加班。 钻研，为了解决一个技术问题会主动学习各方面的资料，勤做实验，用事实去验证；。 和领导和同事及时主动沟通，集思广益，争取各方面的资源，充分利用已有的经验，避免走弯路，加快研发进程。 有强烈的事业心和牺牲精神，不达目标绝不停息。 反之，那些成长慢或者还没有融入研发工作的同志则具有以下特点： 工作没有目标，精力分散，很多的时间花在网络上，偷偷的看视频。 工作推卸责任，把工作没有进展的原因推卸到工作难度太大，或者资源不够，而自己却又不主动的去争取资源。 没有长期为研发乃至个人的职业生涯有充分的打算，或者说来研发的目标比较低下只是为了混口饭吃；人无远虑，必有近忧，没有远大的理想，外界任何一个小的干扰都会让你三心二意，因而知识的学习没有系统性。 和同事和领导的沟通不主动，甚至避让，怕领导检查工作。 更关注生活而不是工作。 比较在意自己的付出。 两种一对照，问题显而易见：研发工作是一项很具挑战性的工作，需要付出艰辛的劳动，需要有扎实的理论基础和动手能力；在开发任务面前头脑清醒，思维敏捷，头绪清晰，有条不紊。遇到困难不会退，遇到挫折不气馁；需要有团队精神，需要有化解矛盾和困难的勇气，智慧和决心，要有相当强的心理素质；因此人员的素质和心理状态是决定性的。上进的同志，稍微带一带，成长速度很快；不主动的同志，工作起来举步维艰，带起来很吃劲，心情也受影响。为了提高研发效率，我们开发了管理软件，制定了各种规章制度。但是，软件和制度只能治标，不能治本，问题的根还是出在人上。应该讲，目前研发部门的软硬件条件和和技术水平，可以让一批想在电子技术嵌入式领域有所作为的年轻人干出骄人成果的。但是现实情况我们也不能过于乐观，研发部门还是存在一些问题的，尤其是人员素质问题。为此我们在参加研发管理培训的时候也咨询过专业人士，他说了一句话：小草永远也长不成苍天大树。所以请各位想想，你现在是小树苗呢，还是草种子？是树是草取决于你是否有强烈的向上成长的愿望，取决于你是否有千方百计吸取土壤养料的勤奋，取决于你对的人生价值的判别，认为现有的土壤值得你扎扎实实定下根来，做一棵这片土壤上的大树。想成为大树的，我们一定创造条件让他(她)成长为大树；如果注定是草种子，我们也无能为力，只有优胜劣汰。 再论能力和勤奋及其他笨鸟先飞早入林，对事物的认知是和事物对大脑的刺激频率和时间成正比的，一个事情经常去做，时候经常去琢磨，就能悟出其中的道理，对事物认识深度是通过在实践中不断发现错误，不断修正才达到的。如果人不勤奋，把过多的时间和注意力放在工作之外的地方，那就自己切断了实践这个重要环节，水平和经验永远得不到提升，能力的提升更谈不上了。接着就是职务，收入上的提升，说到底就是个人在社会上竞争力的提升。不去提升你的核心竞争力，成天沉迷于网络还有其他事物，是否有点舍本逐末呢？ 学习之路大家都是看书，看视频，逛网站，实际中逐步学习来的，这里整理了很多链接和参考书籍给大家学习。尽可能多的编码，要学好C，不能只注重C本身。算法，架构方式等都很重要。 嵌入式书籍推荐Linux基础1、《Linux与Unix Shell 编程指南》C语言基础1、《C Primer Plus，5th Edition》【美】Stephen Prata着2、《The C Programming Language, 2nd Edition》【美】Brian W. Kernighan David M. Rithie（K &amp; R）着3、《Advanced Programming in the UNIX Environment，2nd Edition》（APUE）4、《嵌入式Linux应用程序开发详解》Linux内核1、《深入理解Linux内核》（第三版）2、《Linux内核源代码情景分析》毛德操 胡希明著研发方向1、《UNIX Network Programming》（UNP）2、《TCP/IP详解》3、《Linux内核编程》4、《Linux设备驱动开发》（LDD）5、《Linux高级程序设计》 杨宗德著硬件基础1、《ARM体系结构与编程》杜春雷着2、 S3C2410 Datasheet英语基础1、《计算机与通信专业英语》系统教程1、《嵌入式系统――体系结构、编程与设计》2、《嵌入式系统――采用公开源代码和StrongARM/Xscale处理器》毛德操 胡希明着3、《Building Embedded Linux Systems》4、《嵌入式ARM系统原理与实例开发》 杨宗德著理论基础1、《算法导论》2、《数据结构（C语言版）》3、《计算机组织与体系结构?性能分析》4、《深入理解计算机系统》【美】Randal E. Bryant David O’’Hallaron著5、《操作系统：精髓与设计原理》6、《编译原理》7、《数据通信与计算机网络》8、《数据压缩原理与应用》 C语言书籍推荐 The C programming language 《Ｃ程序设计语言》 Pointers on C 《Ｃ和指针》 C traps and pitfalls 《Ｃ陷阱与缺陷》 Expert C Lanuage 《专家Ｃ编程》 Writing Clean Code —–Microsoft Techiniques for Developing Bug-free C Programs《编程精粹–Microsoft 编写优质无错Ｃ程序秘诀》 Programming Embedded Systems in C and C++ 《嵌入式系统编程》 《C语言嵌入式系统编程修炼》 《高质量C++/C编程指南》林锐 资源网站GitHub 资源OSSU 计算机科学自学：TeachYourselfCS浙江大学课程攻略共享计划：清华大学计算机系课程攻略：嵌入式 LinuxGNU 项目：https://www.gnu.org/GNU 的 FTP 站点：https://ftp.gnu.org/Linux kernel：https://www.kernel.org/Linux kernel 下载地址：https://www.kernel.org/pub/linux/kernel/U-Boot 下载地址：ftp://ftp.denx.de/pub/u-bootBusyBox：https://busybox.net/Bash 下载地址：https://ftp.gnu.org/gnu/bash/ARM交叉编译工具链：https://www.veryarm.com/ARM Developer：https://developer.arm.com/QEMU：https://www.qemu.org/Linux Cross Reference：http://lxr.free-electrons.com/Bootlin：https://bootlin.com/ （Bootlin is an engineering company specialized in embedded Linux）Linux From Scratch：http://www.linuxfromscratch.org/Buildroot：https://buildroot.org/Yocto Project / OpenEmbedded：https://www.yoctoproject.org/Yocto 的 Git 代码库：https://git.yoctoproject.org/OpenEmbedded 的 Git 代码库：https://git.openembedded.org/Gentoo Linux 手册：https://wiki.gentoo.org/wiki/Handbook:X86/Full/Installation/zh-cnUbuntu 软件包检索：https://packages.ubuntu.com/Ubuntu 中文 Wiki：https://wiki.ubuntu.org.cn/Linux 命令大全：https://man.linuxde.net/LINUX.COM：https://www.linux.com/Linux 公社：https://www.linuxidc.com/ （下载的话，用户名与密码都是 www.linuxidc.com）Linux 中国：https://linux.cn/Qt 下载中心：https://download.qt.io/QTCN开发网：http://www.qtcn.org/bbs/i.phpClonezilla（再生龙）：https://sourceforge.net/projects/clonezilla/files/clonezilla_live_stable/跟我一起写 Makefile：https://seisman.github.io/how-to-write-makefile/vim键盘图：http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html书籍教程 很不错的资源，包括部分 GFDL books 《free programming books》：https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md《开源世界旅行手册》：https://i.linuxtoy.org/docs/guide/index.html《鸟哥的Linux私房菜》新网址：https://linux.vbird.org/ 旧网址：http://linux.vbird.org/《Linux就该这么学》：http://www.linuxprobe.com/chapter-00.html《Docker学习笔记》：http://blog.opskumu.com/docker.html《Python全栈工程师学习笔记》：https://book.itxueyuan.com/L8P9/EDMqDocker 中文：http://www.docker.org.cn/book/docker/what-is-docker-16.html菜鸟教程：https://www.runoob.com/IT学院（书籍手册）：https://book.itxueyuan.com/exploreW3C school https://www.w3cschool.cn/ https://www.w3school.com.cn/基础教程网：http://teliute.org/ 学习平台中国大学 MOOC：https://www.icourse163.org/哔哩哔哩（B站）：https://www.bilibili.com/ （B 站是一个很棒的免费学习网站，比如你可以搜集从入门到进阶的英语学习视频。）TED：https://www.ted.com/网易公开课：https://open.163.com/阿里云大学：https://edu.aliyun.com/腾讯课堂：https://ke.qq.com/21ic 公开课：http://open.21ic.com/抖音：https://www.douyin.com/（没错，利用抖音的推荐功能，可以学习很多你想学的东西。）网易云课堂：https://study.163.com/慕课网：https://www.imooc.com/CSDN 学院：https://edu.csdn.net/开课吧：https://www.kaikeba.com/极客学院：https://www.jikexueyuan.com/IT学院：https://www.itxueyuan.com/51CTO 学院：https://edu.51cto.com/粤嵌创客训练营：http://www.geconline.cn/蓝墨云班课：https://www.mosoteach.cn/电子工程摩尔吧：https://www.moore8.com/电子森林：https://www.eetree.cn/硬禾学堂：https://class.eetree.cn/index硬禾实战营：http://www.ecbcamp.com/camp/ 开源硬件Adafruit：https://www.adafruit.com/微雪百科：http://www.waveshare.net/wiki/Main_PageArduino 官网：https://www.arduino.cc/Arduino 中文社区：https://www.arduino.cn/51duino：http://www.51duino.cn/WiFi机器人网：http://www.wifi-robots.com/树莓派：https://www.raspberrypi.org/Beagle Board：https://beagleboard.org/DragonBoard 410c（CSDN开发者专区）：http://qualcomm.csdn.net/英特尔 Embedded Community：https://embedded.communities.intel.com/community/en英特尔中国代理：https://ccechina.intel.com/element14：http://cn.element14.com/pcDuino 开源中国：http://www.oschina.net/hardware/topic/pcduinopcDuino（linksprite）：http://cn.linksprite.com/《pcDuino 开发实战指南》：http://www.pcduino.com/wiki/index.php?title=中文书香蕉派：http://www.banana-pi.org.cn/cubieboard：http://cubieboard.org/cubieboard 中文论坛：http://www.cubie.cc/forum.phpHiKey（LeMaker）：http://www.lemaker.org/cnOpenCores（全世界最大的用于开发开源硬件 IP 核心的网站和社区）：http://opencores.org/OpenHW开源硬件社区：http://www.openhw.org/北京创客空间：http://www.bjmakerspace.com/柴火创客空间：http://www.chaihuo.org/新车间：http://xinchejian.com/ 博客论坛InfoQ：https://infoq.cnCSDN：https://www.csdn.net/开源中国：https://www.oschina.net/稀土官网：https://xitu.io/掘金社区：https://juejin.im/V2EX：https://www.v2ex.com/知乎/简书/StackoverflowRT-Thread 论坛：https://www.rt-thread.org/qa/forum.php正点原子论坛：http://www.openedv.com/野火论坛：http://www.firebbs.cn/forum.php看雪论坛：https://bbs.pediy.com/Deepin 社区：https://www.deepin.org/西邮 Linux 兴趣小组：https://www.xiyoulinux.org/编程练习程序媛计划：https://www.cxy61.com/girl/app/home/home.html 牛客网：https://www.nowcoder.com/ LeetCode:https://leetcode.com/ https://leetcode-cn.com/Codecademy：https://www.codecademy.com/zh/TutorialsPoint：http://www.tutorialspoint.com/ 程序员技术入门免费教程网站，基本上涵盖了你能想到的编程语言和技术框架。 Lynda：https://www.lynda.com/ StuQ：http://www.stuq.org/ 大神网站蜗窝科技：http://www.wowotech.net/廖雪峰：https://www.liaoxuefeng.com/阮一峰：http://www.ruanyifeng.com/何小庆老师：http://allanhe.xtreemhost.com/武晔卿老师：http://www.eefocus.com/武晔卿/blog陈莉君老师的 Linux 内核分析与实践：https://www.mosoteach.cn/web/index.php?c=res&amp;m=index&amp;clazz_course_id=9EA69E8C-D0B0-11E7-AA22-7CD30AD36C02吴章金的Cloud Lab（泰晓实验云台）——基于Docker/Qemu的嵌入式Linux开发环境泰晓科技：https://tinylab.org/首页：http://tinylab.org/linux-lab仓库：https://github.com/tinyclub/linux-lab访问：http://tinylab.cloud:6080/labs周立功专栏：http://www.zlg.cn/LEP项目：http://www.linuxep.com/一个开源的音频分析软件：https://www.audacityteam.org/老设计师 James Greig 的博客：http://greig.cc/吴川斌的博客：https://www.mr-wu.cn/Coding Horror：https://blog.codinghorror.com/ 总结​ 嵌入式对于做个项目，其实是相当重要的，没有嵌入式，就没有我们现在使用的各种电子产品。这也是一个经久不衰的行业，嵌入式的学历由高到低又到高的不断要求，能力始终才是你的根本。希望在嵌入式的金字塔里，大家能够不断的塔尖前行。后续我们将于每周二周四进行更新，为大家带来一个个项目的实践。","link":"/2022/03/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"},{"title":"网络开源技术总结及学习路线思考","text":"网络开源技术总结及学习路线思考最近两天又听了一下网络开源技术生态峰会，第二次，相比去年线下了解起来，自己的知识储备和各种认知都有了一定的增长，听起来要容易理解更多了，从芯片到应用场景简单列举总结一下吧。 芯片 操作系统及软件开源的操作系统还是这些（ONIE/ONL/SONIC/SAI），只是社区有的更活跃了，有的不活跃了。都是OCP组织下的内容。 运营商/设备厂商/互联网厂商联通移动电信三大运营商感觉很厉害，但是我感觉太抽象了，或者说我还需要沉淀，但是好像电信还是去年的讲的更有干货。 华为中兴新华三思科很好奇，为啥华为一直都没有出来过，他们才是龙头呢，起家也是靠程控交换机，干掉了思科。思科的芯片Silicon one Q200,我也了解了一下，交换路由融合芯片，感觉架构师蒋星的演讲好像更精彩一点，可能也是最后一个吧。设备厂商，相对更熟悉一下，还是感觉技术创新太少了。 腾讯阿里百度底层基于sonic，上面具体就不清楚了，阿里只看到了他们的太玄编译器，自研的洛神云网络感觉属于很厉害的云网络，后面需要在学习一下。总之互联网厂商的网络，和运营商的是不太一样的，主要是在数据中心用的更多，虚拟化NFV，容器编排也是用的更多。大厂的容器/k8s网络 目前核心技术 还是内核网络技术：netfilter/iptables+内核协议栈+ebpf+XDP等等 互联网厂商我了解得比较少，我知道的有他们大部分网络设备都是开源白盒，然后自研SDN什么的，希望后面有机会去学习一下。对了，这里互联网厂商有个S3IP的接口规范，这样互联网就能够通过同一套接口来屏蔽设备厂商的硬件差异了。 应用场景不得不提一下目前5G核心网的架构，如图所示（图片来源:《鲜枣课堂》 侵删）,各类MEC 边缘计算，网络分片，算网融合，都离不开核心网，其实大家对整个运营商网络有所了解后，从事技术开发，是能一定程度上帮助大家理解的。无论各种技术，都是为实际场景所服务的，虽然说网络是新基建，我理解在整个框架骨干下，不可能会有太大的革新。 我的理解，这里有几个需求点 节能减排，绿色环保，提高性价比。 提速降费，让大家的网费落到实际。 去繁化简，降低网络的技术门槛。 自主可控，网络安全不容忽视。 也能从各厂商的产品看到，无论是扶持国内的国产厂商，还是优化设备能效比，400G端口出现，SDN的提出，都离不开刚刚说的那些需求。未来也有极大可能朝这个方向演进。大容量，高性能，国产化。 学习路线谈了这些，我们从事相关工作，那需要如何学习呢，这里简单列一下需要涉及的知识面。其实开发测试，售前售后，对技能的需求肯定是不一样的，当然我们的目标那就是架构师，那就都要会，全面学习和掌握，年薪百万(大佬说的年薪能到200w,网络资深专家)。 硬件学习，网卡，ASIC，FPGA Kernel,Network,DPDK 数据路由与交换技术 运营商网络，园区网络，数据中心网络 OSI TCP/IP 入门 一入网络深似海，上面的知识只是入门，真正的专家or架构，我理解需要的技术深度应该远不止于此。 随便举个例子，DPDK的架构图，就有这么多内容。 总结和思考方向既然已经选择好了，为什么不努力一点呢。机会总会留给有准备的人的。把自己当作一个项目去打磨，这也是《做个项目》呀。 向着理想迈步，总有一天你会到达比别人更高的山峰。","link":"/2022/05/26/%E7%BD%91%E7%BB%9C%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%80%9D%E8%80%83/"}],"tags":[{"name":"c","slug":"c","link":"/tags/c/"},{"name":"zbar","slug":"zbar","link":"/tags/zbar/"},{"name":"图像处理","slug":"图像处理","link":"/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"coding","slug":"coding","link":"/tags/coding/"},{"name":"嵌入式","slug":"嵌入式","link":"/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[]}